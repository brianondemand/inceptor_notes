## Redundancy in networks – why it is important

Redundancy is an essential part of network design. Modern networks are expected to run 24/7/365. Even a short downtime can be disastrous for a business.

Redundancy must be implemented at every possible point in a network. If one network component fails, other components should be able to step in and take over the functions of the failed components to ensure the system experiences little or no downtime.

Network engineers are responsible for business-critical infrastructure and they must ensure that the network infrastructure is resilient to failures as much as possible.

Here is an example of a poorly designed network. There are many potential points of failure which could disconnect the network.

![no-redundancy-network](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/46c28-no-redundancy-network.webp?w=1201)


For example, if the connection between the router and the Internet is cut due to a hardware failure, this entire network loses connectivity to the Internet. If the connection marked by a red X is cut off due to a hardware failure, the hosts in the red box lose connectivity within the LAN, and out to the Internet.

Here’s a better network design.

![Redundancy-networks](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/e92dc-redundancy-networks.webp?w=1201)


For example, if the PC in the red box wants to reach the Internet, it might use the lower path in a normal situation; however, if the router (marked with a red X) in the lower path has a hardware failure and goes down, the PC can reach the Internet via another alternative path (shown with the red arrows).

## Layer 2 loops (broadcast storms)

Spanning Tree enables redundant Layer 2 networks. We saw how a redundant LAN can be beneficial. Having multiple paths between switches provides alternate paths if one connection fails.

But there’s a catch. A network with redundant paths can result in Layer 2 loops.

Consider this network layout. It screams out, “I want my Spanning Tree!” There is a problem that can cripple the network. A broadcast storm can form.

![network-with-redundant-paths](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/bfa51-network-with-redundant-paths.webp?w=1201)


Let’s use a simplified network topology to illustrate the concept of broadcast storms.

![concept-broadcast-storms](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/a428e-concept-broadcast-storms.webp?w=1201)


PC1 is 10.0.0.1, PC2 is 10.0.0.2, and PC3 is 10.0.0.3. PC1 wants to send some traffic to PC2. To do that, it needs to know PC2’s MAC address. So PC1 sends an ARP request, which is a broadcast frame that uses the broadcast MAC address of all F’s as its Layer 2 address. When SW1 receives the broadcast frame, SW1 will flood the frame out of all interfaces, except the one it was received on. Recall, a switch will flood broadcast and unknown unicast frames. SW2 and SW3 both receive a copy of the frame. SW2 and SW3 will then flood the frame out all interfaces except the one it was received on. PC2 receives the ARP request and will reply with a unicast ARP reply.

So where is the problem?

Although PC2 received the ARP request and sent its reply, broadcast frames remain on the network (notice the yellow rectangle between SW3 and SW2). The switches will keep flooding the frames. SW1 might receive two broadcast frames on two different interfaces, and again flood them. Similarly, SW2 and SW3 may also keep receiving and flooding broadcast frames in an infinite loop type scenario.

If enough of these looped broadcasts accumulate in the network, the network will be too congested for legitimate traffic to use the network. This is called a **broadcast storm.**

The IP header has the TTL or Time To Live field, used to prevent infinite loops at Layer 3. The Ethernet header does not have a TTL field.

Eventually the network will be full of looping broadcast frames such that no regular traffic can pass through the network.

![broadcast-storm-illustration](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/ef5bb-broadcast-storm-illustration-5.webp?w=1201)


The red arrows represent the clockwise loop between the three switches and the purple arrows represent the counter-clockwise loop.

Network congestion is not the only problem. Each time a frame arrives on a switchport, the switch uses the source MAC address field to learn the MAC address and update its MAC address table. When the frames with the same source MAC address repeatedly arrive on different interfaces, the switch is continuously updating the interface in its MAC address table. This is known as **MAC Address Flapping.**

*So how can we design a network with redundant paths that does not result in Layer 2 loops?*

One way is to use a Spanning Tree protocol (STP). STP works by electing a root bridge for the network and then building a Spanning Tree that includes all of the switches in the network. The Spanning Tree includes only one path between any two devices in the network. If a link fails, STP will automatically recalculate the Spanning Tree and open a new path.

## The role of classic STP in regulating traffic flow within Ethernet segments

A network loop occurs when there are two or more redundant paths between two network devices. This can cause broadcast storms, which can flood the network with unnecessary traffic and bring the network to a halt. STP prevents Layer 2 loops by blocking redundant paths.

Switches use **BPDUs (Bridge Protocol Data Units)** to communicate with each other and to build the Spanning Tree.

Classic STP works by electing a root bridge, which is the central point of the network.

Once the network topology has converged and all switches agree on the root bridge, only the root bridge sends BPDUs. The reason all switches send BPDUs at first is because they all think they are the root bridge.

STP still uses the term bridge, though bridges are not used much in modern networks. When we use the term bridge in our present discussion on STP, we really mean switch.

Classic STP prevents network loops within LANs by blocking ports that are not necessary for traffic flow. This ensures that there is only one path between any two network devices, which prevents broadcast storms from occurring.

Each link between two switches is a separate collision domain (Ethernet segment). Every collision domain has a single Spanning Tree designated port. Designated ports are in a forwarding state. The switch forming a connection (link) with the switch with the designated port will make its port non-designated (blocking). Blocked ports do not forward traffic, which prevents network loops from forming.

STP is a simple and effective way to prevent network loops in switched networks. However, it can have some drawbacks/limitations, such as:

- Slow convergence time: Classic STP can take a long time to converge after a topology change. This can cause disruption to network traffic.
- Not scalable: Classic STP can become inefficient in large networks with a large number of switches and links.
- Not resilient to link failures: If a link fails, Classic STP can take a significant amount of time (some 30-50 seconds) to re-calculate the Spanning Tree and open a new path. This can cause disruption to network traffic.

To address these limitations, newer STP protocols have been developed, such as Rapid STP (RSTP) and Multiple Spanning Tree Protocol (MSTP). These protocols offer faster convergence time, better scalability, and more resilience to link failures.

- Faster convergence time: RSTP and MSTP converge in a few seconds.
- More resilient to link failures: RSTP and MSTP can re-calculate the Spanning Tree and open a new path more quickly if a link fails.
- Supports multiple topologies: MSTP can support multiple topologies in a single network, which can improve network scalability.

## Introduction to STP

\*Switches from all vendors run STP by default. Classic STP is IEEE 802.1D. This is the type of STP we will focus on in STP Part 1.

\*STP prevents Layer 2 loops by placing redundant ports in a blocking state, essentially **disabling the interface**. Interfaces in a blocking state act as backups that can enter a forwarding state if an active interface (an interface that is currently forwarding) fails.

\*Interfaces in a forwarding state behave normally. They send and receive all normal traffic. However, interfaces in a blocking state only receive STP messages called **BPDUs** (beside some other overhead messages).

\*Only the root bridge initiates BPDU transmissions. Other switches forward the BPDUs they receive. BPDUs are the workhorses of STP. They carry various types of information switches exchange to build and maintain the loop-free network.

\*STP-enabled switches send Hello BPDUs out of all ports (except blocking ports) once every 2 seconds. Hello messages are a specific type of BPDU. They primarily function as a heartbeat, informing other switches the sending switch is alive and participating in STP.

If a switch receives a Hello BPDU on an interface, it knows the interface is connected to another switch. Routers, PCs, servers, and wireless APs typically do not use STP, they do not send Hello BPDUs.

## STP demonstration

If we look at this topology again, these green-lit interfaces are in a forwarding state, while the one orange-lit interface on SW3 is in a blocking state, effectively disabling the connection between SW2 and SW3.

![STP-demonstration](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/87371-stp-demonstration-6.webp?w=1201)


If PC1 sends an ARP request (a broadcast frame), it will be flooded as follows. No loops.

![STP-demo](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/e720c-stp-demo-7.webp?w=1201)


If at some point another interface fails, say the interface on SW2 receiving traffic from SW1, the switches will automatically adjust the topology and the broadcast frame would be flooded as follows. Again, no loops.

![STP-demo](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/2a3da-stp-demo-8.webp?w=1201)


\*By selecting which ports are forwarding and which ports are blocking, STP creates a single path to and from each point in the network. This prevents Layer 2 loops.

*\*There is a set process that STP uses to determine which ports should be forwarding and which should be blocking.*

That process is what we will cover next.

## STP process

Here is a summary of the process of selecting the different [port roles and states in a Spanning Tree](https://itnetworkingskills.wordpress.com/2023/03/24/classic-spanning-tree-port-states/) network.

When the switches first come up, they start the root switch election process. Each switch transmits a BPDU to the directly connected switch on a per-VLAN basis.

1\. One switch per VLAN is elected as the root bridge, the switch with the lowest Bridge ID. All ports on the root bridge are designated ports (in a forwarding state).

As the BPDU goes out through the network, each switch compares the BPDU that the switch sends to the BPDU that the switch receives from the neighbors. The switches then agree on which switch is the root switch. The switch with the lowest Bridge ID in the network wins this election process.

2\. Each remaining switch selects one of its interfaces to be a root port.

Each switch determines the best path to get to the root. The switches determine this path by a comparison of the information in all the BPDUs that the switches receive on all ports. The switch uses the port with the least amount of information in the BPDU in order to get to the root switch; the port with the least amount of information in the BPDU is the root port.

2.1. The interface with the lowest root cost is selected. If that’s a tie,

2.2. The interface connecting to a neighboring switch with the lowest Bridge ID is selected. If that’s a tie also,

2.3. The interface connected to the lowest port ID on the neighbor switch is selected.

The root port must be set to forwarding mode.

Ports across from the root port are always designated ports.

3\. Each remaining collision domain will select one interface to be a designated port (in a forwarding state), and the other port will be non-designated (the switch forming a connection with the switch with the designated port will make its port non-designated, in a blocking state). The interface on the switch with the lowest root cost will be designated. If that’s a tie, the interface on the switch with the lowest Bridge ID will be designated.

The switches on each LAN segment communicate with each other to determine which switch is best to use in order to move data from that segment to the root bridge. This switch is called the designated switch.

Back to our topology. These switches will send BPDUs out of each interface (follow the green arrows). The switches use these BPDUs to advertise themselves to other switches and to learn about other switches.

![Root-bridge-election](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/0a738-root-bridge-election-9.webp?w=1201)


What exactly are these BPDUs used for?

\*Switches use the **Bridge ID** field in the STP BPDU to elect a **root bridge** for the network.

*\*The switch with the lowest Bridge ID becomes the root bridge.*

Traditionally, the Bridge ID field of the Spanning Tree BPDU looked like this. There is a Bridge Priority field, 16 bits in length, and there is the MAC address of the switch, 48 bits in length.

![traditional-Bridge-ID-field](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/1e152-traditional-bridge-id-field-10.webp?w=1201)


The default Bridge Priority is 32768 on all switches, so by default the MAC address is used as the tiebreaker. The switch with the lowest MAC address becomes the root bridge. The Bridge Priority is compared first, if there is a tie the MAC address is then compared.

## Root bridge election demo

Here’s that topology again.

![traditional-Bridge-ID-field](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/27efe-traditional-bridge-id-field-11.webp?w=1201)


The priority (Bridge Priority) and MAC address for each switch are given. MAC addresses are shortened to three characters for convenience (they are actually 12 hexadecimal digits). Green-lit Interfaces are forwarding.

The G0/2 interface on each switch is connected to a PC. Because the G0/2 interface on each switch is not receiving any BPDUs, the switch knows it is safe to go into forwarding mode. There is no risk of creating a Layer 2 loop, so these port lights are all green.

All three switches have the default priority of 32768. To know which switch will be the root bridge we compare the MAC addresses. The lowest Bridge ID wins.

SW1 has the lowest MAC address. Therefore, SW1 becomes the root bridge of this network (hexadecimal A is equal to 10, B is equal to 11, and C is equal to 12).

All ports on the root bridge become **designated ports**, in a forwarding state.

## PVST+, extended system ID

The Bridge ID we saw earlier was the traditional Bridge ID. However, the Bridge ID has been updated to look like this.

The **Bridge Priority (16 bits)** has been updated to be made of two parts, the **bridge priority field (4 bits)**, and the **extended system ID field (12 bits)**, which is the **VLAN ID**.

![updated-bridge-id-field](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/ac1f7-updated-bridge-id-field-12.webp?w=1201)


**Why include a VLAN ID in the Bridge Priority?**

In classic STP, all VLANs share one STP instance. This means that all ports in the network are part of the same STP topology. When STP converges, it blocks all but one port between any two switches. This is done to prevent loops from forming in the network.

If we want to block different ports in each VLAN to achieve load balancing, we need to use a different STP mode. One option is to use PVST+ (Per VLAN Spanning Tree Protocol). PVST+ is a Cisco proprietary STP mode that allows for multiple STP instances to be configured in the same network.

PVST+ runs a separate STP instance in each VLAN. For example, if you have a network with 10 VLANs, you could have 10 STP instances running on each switch, one instance for each VLAN. In each VLAN different interfaces can be forwarding or blocking. One interface could be forwarding in VLAN1, but blocking in VLAN2, for example. This would allow you to have different root bridges and topologies for each VLAN, and you could also configure different ports in each VLAN to be used for different traffic flows.

By adding the VLAN ID into the Bridge Priority, a switch can have a different Bridge ID in each VLAN.

Here’s a closer look at the Bridge Priority field.

![Bridge-Priority-field](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/87f0d-bridge-priority-field-13.webp?w=1201)


32768 is the default Bridge Priority because the Bridge Priority field is 16 bits in length (2^0 → 2^15), and the most significant bit in the field is set to 1 by default (2^15 = 32768).

However, with the addition of the extended system ID, the VLAN ID, this default value changed. The default VLAN ID is 1. Therefore the default Bridge Priority in total is 32769.

In the default VLAN of 1, the default Bridge Priority is 32769, which is 32768 + 1.

Ponder this: if you want to increase the switch’s Bridge Priority without changing VLAN numbers, what is the minimum unit of increase/decrease?

The bridge priority and extended system ID together are a single field in the Bridge ID, i.e., the Bridge Priority field. However, the extended system ID is set and cannot be changed because it is determined by the VLAN ID. Therefore, you can only change the total Bridge Priority (that is, the bridge priority + extended system ID) in units of **4096**, the value of the least significant bit of the bridge priority portion.

The Bridge Priority is 32769. If we want to reduce it, just a little, on a switch to make the switch the root bridge, we can reduce it to 28673, which is 16384 plus 8192 plus 4096 plus 1 (or 32769 – 4096).

![bridge-priority-field](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/5be92-bridge-priority-field-14.webp?w=1201)


We could reduce the Bridge Priority more, but the point is this: the STP Bridge Priority can only be changed in units of 4096. The valid values you can configure are shown in the above diagram, starting from 0 and increasing in units of 4096.

## Root bridge (cont.)

Some key points about the root bridge…

\*When a switch is powered on, it assumes it is the root bridge. A switch will only give up its position if it receives a superior BPDU, meaning, a BPDU from a switch with a lower Bridge ID.

\*Once the topology has converged and all switches agree on the root bridge, only the root bridge sends BPDUs. The reason all switches send BPDUs at first is because they all think they are the root bridge.

Other switches in the network will forward BPDUs from the root bridge, but they will not generate their own original BPDUs.

\*STP puts ports in either a blocking or forwarding state to avoid Layer 2 loops in the network.

All ports on the root bridge are put in a forwarding state, and all other switches in the topology must have a path to reach the root bridge.

Let’s look at the topology again (the diagram below). We will be looking at the STP topology for a single VLAN, VLAN1, the default VLAN on a switch.

The priority Pri (the Bridge Priority) for each switch is 32769. But if there are multiple VLANs, say VLAN1, VLAN2, and VLAN3 in this network, the priority would be 32770 for VLAN2, and 32771 for VLAN3, and so on.

So here in VLAN1, SW1 is the root bridge. All interfaces on the root bridge are designated ports. Designated ports are in a forwarding state.

![root-bridge](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/a6fdd-root-bridge-15.webp?w=1201)


Note, just FYI for now, we could also change the priority on the switches for a specific VLAN. For example, SW1 could be the root bridge in VLAN1, SW2 could be the root bridge in VLAN2, and SW3 could be the root bridge in VLAN3.

## Classic STP port roles

\*Root ports: ports on non-root switches (switches that are not the root bridge in a Spanning Tree network) with the best root cost to the root bridge. There can only be one root port per switch. These ports forward data to the root bridge.

\*Designated ports: ports on root switches and designated switches. All ports on the root bridge will be designated. Ports across from (connected to) the root port are always designated ports.

\*Non-designated/blocked ports: all other ports to switches are in a blocked state (access ports going to workstations or PCs are not affected). The non-designated port is a switch port in a blocking state, so it is not sending BPDUs, not populating the MAC address table with source addresses, and not forwarding data frames.

## Root port selection via root cost

So far we have covered the **first step** of Spanning Tree’s process of creating loop-free Layer 2 LANs: the switch with the lowest Bridge ID is **elected** as the **root bridge**. All ports on the root bridge are **designated ports**, so they are in a forwarding state.

The **second step** is: all other switches will **select** one of its ports to be its **root port**. That means there is **one root port on each switch** in the network. Root ports are also in a forwarding state.

The interface with the lowest **root cost** becomes the **root port**.

The root cost is the total cost of the outgoing interfaces along the path to the root bridge.

## Root cost

Each interface has an associated Spanning Tree cost. Remember these path costs for the CCNA exam.

| **Speed** | **STP cost** |
| --- | --- |
| 10 Mbps (Ethernet) | 100 |
| 100 Mbps (Fast Ethernet) | 19 |
| 1 Gbps (Gigabit Ethernet) | 4 |
| 10 Gbps (Gigabit Ethernet) | 2 |

In our topology, we are using Gigabit Ethernet ports, so they all have a cost of 4. We count the cost of the sending, the outgoing interface, not the cost of the receiving interface. SW1 is the root bridge, so it has a cost of 0 on all interfaces. SW1 advertises its root cost of 0 in its BPDUs.

![Root-port-selection-root-cost](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/91615-root-port-selection-root-cost-16.webp?w=1201)


SW2 will choose G0/1 as its root port. Here is its logic. SW2 was advertised a cost of 0 on its G0/1 interface, however the cost of its interface is 4, therefore the total root cost via G0/1 is 4. SW2 was advertised a cost of 4 on G0/0, from SW3. However its interface also has a cost of 4, so the total root cost via G0/0 is 8. So SW2 will select G0/1 as the root port.

SW2 will receive the BPDU from SW1 and add the cost of its outgoing interface, G0/1, which is 4, when it floods those BPDUs out of its interfaces. SW3 will do the same.

SW3’s logic follows the same process. SW3 has a total cost of 4 via G0/0, and a total cost of 8 via G0/1, so it will select G0/0 as its root port.

In this case, the ports directly across from each root port are the root bridge, so they are already designated ports. Keep in mind that **the port connected to another switch’s root port must be designated**. Because the root port is the switch’s path to the root bridge, another switch must not block it.

## Root port selection via neighbor Bridge ID

Let’s review the process of figuring out a Spanning Tree topology.

1\. One switch is elected as the root bridge. All ports on the root bridge are designated ports (in a forwarding state). There is only one step in selecting the root bridge, that is, the switch with the lowest Bridge ID.

2\. Each remaining switch will select one of its interfaces to be its root port (which is also in a forwarding state). Ports across from (connected to) the root port are always designated ports.

Criteria for root port selection:

2.1. The interface with the lowest **root cost** becomes the **root port**. If we need a tiebreaker, if a switch has multiple ports with the same root cost,

2.2. The interface connected to the neighbor switch with the lowest Bridge ID becomes the root port. If it’s a tie,

2.3. The interface connected to the lowest port ID on the neighbor switch becomes the root port.

## Identify root bridge, root ports

Let’s identify the root bridge and root ports in a topology.

SW2 will become the root bridge because it has the lowest priority (Bridge Priority). So SW2’s ports are all designated.

![Identify-root-bridge](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/485df-identify-root-bridge-17.webp?w=1129)


Which ports will become root ports? All interfaces are Gigabit Ethernet, so they all have a cost of 4. If there is a tie in root cost, the switch will select the interface connected to the neighbor with the lowest Bridge ID.

On SW1 and SW4, the answer is obvious, SW1’s G0/0 and SW4’s G0/1 have a cost of 4 each, so they are selected.

SW3 via G0/0 has a cost of 8 (4 plus 4); via G0/1 it has the same cost of 8 (4 plus 4). So we have to use the tiebreaker: which neighbor switch has the lowest Bridge ID, SW1 or SW4? It’s SW1, the priorities are the same, but SW1’s MAC address is lower. So SW3’s G0/0 is selected as the root port, and SW1’s G0/1 becomes designated.

## Root port selection via neighbor port ID

There is one more tiebreaker that might be needed to select the root port: lowest neighbor port ID.

What if two switches have two connections between them, so both the root cost and the neighbor Bridge ID are the same? Then we get to the final tiebreaker: the interface connected to the interface on the neighbor switch with the lowest port ID will become the root port.

Here is the output of the command **show spanning-tree.** The command output lists the Spanning Tree port ID of each interface on the switch.

![stp-port-id](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/42afd-stp-port-id-18.webp?w=1027)


Note the column titled Prio.Nbr (Prio dot number) which is the STP port ID. Each port has a default priority of 128, and then a unique port number, 1 for G0/0, 2 for G0/1, etc. on this switch. The STP port ID equals the port priority plus the port number. Similar to the Bridge ID, where the MAC address is used as a tiebreaker if the priorities tie, in this case the port number is used as a tiebreaker if the priorities tie.

**Let’s look at an example: identify the root port**

SW2 is still the root bridge, but now there are two connections between SW1 and SW3. Which port will SW3 select as the root port? **First**, the root cost is the same for both interfaces, 8. **Second**, which interface is connected to the neighbor with the lowest Bridge ID? Again, the same for both interfaces. **Third,** which interface is connected to the lower port ID **on the neighbor switch**? SW3’s G0/2 interface.

![stp-port-id](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/94e3f-stp-port-id-19.webp?w=1122)


SW3’s G0/2 interface will become the root port, because it is connected to a lower port ID on the neighbor switch – SW1’s G0/1 interface has a lower port ID than its (SW1’s) G0/2 interface.

SW1’s G0/1 interface is a designated port, because it is connected to SW3’s root port.

## Blocking ports to prevent loops

So far we have covered **two key steps** of Spanning Tree’s process of creating loop-free Layer 2 LANs: 1) switches **elect** a root bridge, and 2) switches each **select** one of its ports to be its **root port**.

Our process is not yet complete. We need to block some ports to prevent Layer 2 loops.

So let’s look at the **third key step**: each remaining collision domain selects one designated port and one non-designated port.

All that’s left is the connection between SW2 and SW3. Notice the red rectangle representing the connection between SW2’s G0/0 and SW3’s G0/1 that needs a blocked port to prevent loops.

![Blocking-ports-prevent-loops](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/8d35d-blocking-ports-prevent-loops-20.webp?w=1201)


Each link between two switches is a separate collision domain. Every collision domain (Ethernet segment) has a single Spanning Tree designated port. The collision domain between SW1 and SW2 has one designated port, SW1’s G0/0. The connection between SW1 and SW3 has one designated port, SW1’s G0/1.

The connections with the PCs are all designated ports in the forwarding state, because the PCs do not participate in Spanning Tree.

We need one designated port on the connection between SW2 and SW3.

How do we determine which port will be designated, in a forwarding state? The switch with the lowest root cost will make its port designated. However, in this case both switches have the same root cost, 4 for SW2 via its G0/1 interface and 4 for SW3 via its G0/0 interface.

For the tiebreaker we compare the Bridge ID. SW2 has the lower Bridge ID, so its G0/0 interface will be designated. Finally, the other switch will make its port non-designated, which means it is in a blocking state, it blocks the port to prevent Layer 2 loops. SW3’s G0/1 is non-designated.

---

## Classic Spanning Tree port states

STP Part 1  looked at the forwarding and blocking STP port states. There are a couple of other transitional states between those two, listening and learning, and some timers that determine when the switch moves between each state.

Forwarding and blocking are stable states. Listening and learning are transitional states.

\*Root ports and designated ports remain stable in a forwarding state, and non-designated ports remain stable in a blocking state.

\*Root and designated ports only remain stable as long as there are no changes in the network topology. If a new device is added, an interface is shutdown, or a hardware failure occurs in the topology, ports may have to change states.

\*Listening and learning are transitional states which are passed through when an interface is activated or when a blocking port must transition to a forwarding state due to a change in the network topology.

\*The disabled state refers to an interface that is administratively disabled, meaning shutdown.

**STP port states interface modes**

![STP-port-states-interface-modes](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/11310-stp-port-states-interface-modes.webp?w=669)

STP port states interface modes

**The blocking state**

\*Non-designated ports are in a blocking state.

\*Interfaces in a blocking state are effectively disabled to prevent loops. Disabling redundant interfaces prevents loops.

\*Interfaces in a blocking state do not send/receive regular network traffic. Regular traffic arriving on an interface in a blocking state is dropped.

\*However, interfaces in a blocking state receive STP BPDUs. Interfaces in a blocking state need to receive and process BPDUs to participate in the Spanning Tree topology and be ready to transition to a forwarding state if they need to.

\*Interfaces in a blocking state do not forward STP BPDUs.

\*Interfaces in a blocking state do not learn MAC addresses. If regular traffic arrives on the interface it is dropped.

**The listening state**

\*After the blocking state, interfaces with a designated or root role enter the listening state. In the listening state a switch port does not forward traffic, but does listen for BPDUs. This allows the switch to learn about the topology of the network before it begins forwarding traffic.

\*Only designated and root ports enter the listening state. Non-designated ports are always blocking. There is no need for a non-designated port to enter the listening state because the listening state is a transitional state that eventually leads to a forwarding state.

\*The listening state is 15 seconds long by default. The length of the listening state is determined by a timer called the forward delay timer. The default value of the forward delay timer is 15 seconds.

\*An interface in the listening state only forwards/receives Spanning Tree BPDUs.

\*An interface in the listening state does not send or receive regular traffic. If a port in the listening state receives a regular unicast frame, the switch will discard the frame.

\*An interface in the listening state also does not learn MAC addresses from regular traffic that arrives on the interface.

When a frame arrives on a switch interface, the switch uses the frame’s source MAC address field to learn about that MAC address. The switch updates its MAC address table with the MAC address, interface, and VLAN information. If an interface is in the STP listening state, this does not happen. Traffic is simply dropped.

**The learning state**

\*After the listening state, a designated or root port will enter the learning state.

\*The default length of the learning state is 15 seconds. This default time is determined by the forward delay timer (the same timer is used for both the listening and learning states), so by default it takes a total of 30 seconds to move through both states and enter a forwarding state.

\*As in the listening state, an interface in the learning state only sends or receives STP BPDUs. An interface in the learning state does not send or receive regular traffic.

\*However, an interface in the learning state learns MAC addresses from regular traffic that arrives on the interface. An interface in the learning state builds up some of its MAC address table in preparation for the forwarding state.

**The forwarding state**

\*All ports on the root bridge become designated ports, in a forwarding state.

\*Root and designated ports are in a forwarding state when they are stable.

\*A port in the forwarding state operates as normal. Meaning, the port 1) sends and receives BPDUs, 2) sends and receives normal traffic, and 3) learns MAC addresses from the frames that arrive on it, and adds them to the MAC address table. It is a switch port operating as normal.

## STP port states chart

Here is another summary of each STP port state.

![STP-port-states-chart](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/a0267-stp-port-states-chart.webp?w=1201)


Try to remember these states, which states send and receive BPDUs, which states forward traffic, which states learn MAC addresses, and which states are stable and which states are transitional.

## Spanning Tree timers

Now we discuss the timers used in Spanning Tree – hello, forward delay, and max age timers.

![Spanning-Tree-timers](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/0380a-spanning-tree-timers.webp?w=1201)


**First up, the hello timer.**

The hello timer is a setting on the root bridge that determines how often the root bridge sends hello BPDUs. By default, the hello timer is set to 2 seconds. This means that the root bridge will send a hello BPDU every 2 seconds.

Other switches in the network do not originate their own BPDUs, but they will forward BPDUs they receive. However, switches will only forward BPDUs on their designated ports.

Let’s see how that works.

Assuming these switches all come online at the same time, each switch will assume it is the root bridge, and each switch will send BPDUs out of all interfaces.

![stp-hello-timer-demo](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/17abb-stp-hello-timer-demo-4.webp?w=1201)


However, once the network has converged and all switches and ports are stabilized in their roles, only the root bridge sends BPDUs.

![stp-hello-BPDU-demo](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/7fc19-stp-hello-bpdu-demo-5.webp?w=1201)


Then, the other switches will forward these BPDUs on their designated ports, updating information like the bridge root cost, Bridge ID, port ID, etc.

![stp-hello-BPDU](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/9d51f-stp-hello-bpdu-6.webp?w=1201)


After 2 seconds, the root bridge will send BPDUs again, and the other switches will again forward these BPDUs on their designated ports.

**Next up, the forward delay timer.**

This is the length of the listening and learning transitional states that a port goes through when it moves to forwarding.

This is not the total length of both transitional states combined. With the default forward delay timer of 15 seconds for each state, it takes a total of 30 seconds for the switch port to move through both states and forward traffic.

**The final timer is the max age timer.**

This timer indicates how long an interface will wait to change the Spanning Tree topology after ceasing to receive Hello BPDUs. The timer is reset every time a BPDU is received.

Each collision domain has one designated port. BPDUs are forwarded out of designated ports. All root ports and non-designated ports expect to receive BPDUs.

The root bridge, SW3, sends BPDUs, and then SW1 and SW4 forward them out of their designated ports.

![stp-max-age-timer](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/c608b-stp-max-age-timer-7.webp?w=1051)


To demonstrate how the max age timer works, let’s focus on SW2’s G0/1 interface. It just received a BPDU, so the max age timer of SW2’s G0/1 interface is reset to 20. It counts down to 18. And then the root bridge sends BPDUs, because of the 2 second hello timer. SW2 resets its max age timer to 20. It starts counting down again: 19, 18. And on and on it goes.

Suppose a failure occurs on the connection between SW1 and SW2, and SW1’s G0/0 interface goes down. The root bridge will send BPDUs, and other switches will forward the BPDUs. Because SW1’s G0/0 interface is down, SW2 no longer receives a BPDU on its G0/1 interface.

So the max age timer continues counting down. 17, 16, 15 … and if the failure does not recover and SW2 does not receive any more BPDUs on its G0/1 interface, SW2’s max age timer will count all the way down to 0. What happens next?

\*If another BPDU is received before the max age timer counts down to 0, the time will reset to 20 seconds and no changes will occur.

\*However, if another BPDU is not received and the max age timer counts down to 0, SW2 will reevaluate its STP choices, including root bridge, and local root, designated, and non-designated ports.

\*After these decisions, if a non-designated port is selected to become a designated or root port, the port will transition from the blocking state to the listening state (for 15 seconds), learning state (again for 15 seconds), and then finally the forwarding state. So it can take a total of 50 seconds for a blocking interface to transition to forwarding.

A blocking interface cannot move directly to forwarding state. It must go through the listening and learning states.

However, a forwarding interface can move directly to a blocking state, since there would be no concern about creating a loop by blocking an interface.

These timers and transitional states are meant to make sure that loops are not accidentally created by an interface moving to a forwarding state too soon.

## STP BPDU (Bridge Protocol Data Unit)

Let’s look at a Spanning Tree BPDU Wireshark packet capture. Let’s explore what fields are included in the STP BPDU and what is their purpose.

BPDUs are encapsulated in an Ethernet frame. In the Ethernet frame, the BPDU is located in the **LLC (logical link control)** header.

The following diagram shows an Ethernet frame with a BPDU:

Destination MAC Address | Source MAC Address | 802.1Q VLAN tag | Type/Length | LLC header | BPDU header | Data | FCS

STP/RSTP defines messages called bridge protocol data units (BPDU), also called configuration BPDUs, which switches use to exchange information with each other. The most common BPDU, called a Hello BPDU, lists many details, including the sending switch’s BID. By listing its own unique BID, switches can tell which switch sent which Hello BPDU. Table 9-4 lists some of the key information in the Hello BPDU. (Odom, 2020, p. 218 Vol. 1)

Table 9-4 Fields in the STP Hello BPDU (Odom, 2020, p. 218 Vol. 1)

Spanning Tree BPDU Wireshark packet capture

![BPDU-wireshark](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/27d8c-bpdu-wireshark-8.webp?w=976)


First off, in the Ethernet header section, notice the destination (Dst). A switch sends BPDUs using the source MAC address from its origin port to a multicast address with a destination MAC of 01:00:0C:CC:CC:CD for Cisco proprietary PVST+. Regular Spanning Tree uses a destination MAC address of 01:80:c2:00:00:00, a multicast address. Remember these MAC addresses for the CCNA exam.

Let’s look at the BPDU itself (section “Spanning Tree Protocol”).

\>The first three fields are: 1) the Protocol Identifier, which is always hexadecimal 0000 for Spanning Tree; 2) the Protocol Version Identifier is set to 0 for classic Spanning Tree (the protocol version in an RSTP BPDU is 2); and 3) the BPDU Type is hexadecimal 00 for a configuration BPDU.

\>Next up are BPDU flags. These are used to signal topology changes to other switches.

\>Next up is the Root Identifier, which gives the bridge priority, extended system ID (the VLAN ID), 10 in this case, and the bridge system ID, which is the MAC Address of the root bridge. The MAC address is set to all a’s in this case.

\>Next is the Root Path Cost. It is 0 in this case, so you know that this is the root bridge. You can also know that this is the root bridge by looking at the information in the Bridge Identifier field. The information in the Bridge Identifier field is the same as in the Root Identifier field, so this is the root bridge.

\>Next is the Port identifier (Port ID), the port that sent the BPDU. It is hexadecimal 8002. 80 in hexadecimal is equivalent to 128, which is the default port priority. 02 is the number of the port itself.

\>Finally, the timers: Message Age, Max Age, Hello Time, and Forward Delay. We have not discussed message age, but it is essentially the time it takes for a BPDU to expire and has a default value of 20 seconds.

The STP timers on the root bridge determine the STP timers for the rest of the switches in the network, even if they are configured differently.

## STP optional features (STP Toolkit)

STP optional features, sometimes called STP Toolkit, are additional features that can be enabled on switches to improve the functionality (performance, security, and reliability) of STP. Some of the most common STP optional features include **PortFast, BPDU Guard, and Root Guard.**

**STP Toolkit PortFast**

PortFast solves one problem of Spanning Tree. PortFast allows a switch port to transition to the forwarding state immediately, bypassing the listening and learning states. This can be useful for connecting end devices to a switch, as it allows them to access the network more quickly.

PortFast can be enabled on interfaces connected to end hosts, like the G0/2 interface on each of these switches (the red boxes). These are designated ports, in a forwarding state.

![PortFast-illustration](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/8cba4-portfast-illustration-9.webp?w=1201)


When interfaces are first turned on or first connected to the PCs, they must first go through the listening and learning states before they can start forwarding traffic. This process takes 30 seconds in total.

Since only interfaces connected to another switch can form a Layer 2 loop, there is no risk of forming a loop with an end host. So there is no point in making these ports wait 30 seconds to transition to forwarding.

If used, PortFast must be enabled only on ports connected to end hosts. If enabled on a port connected to another switch it could cause a Layer 2 loop.

PortFast is enabled at the interface level with the command **spanning-tree portfast**.

![spanning-tree-portfast-cli](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/8c624-spanning-tree-portfast-cli-10.webp?w=1201)

When we enter the command we get a warning that PortFast should only be enabled on ports connected to an end host. There is also a message saying that even though portfast was configured, it will only take effect if the interface is in a non-trunking mode (so if it is an access port). This is because trunk ports are typically connected to other switches. If you configure PortFast on a trunk port, you will get no effect.

You can also enable PortFast with the following command in global config mode:

SW1(config)#spanning-tree portfast default

This enables PortFast on all access ports, but not trunk ports.

PortFast can be a risk. Consider what may happen if an employee plugged another switch into the network, as shown below. Because PortFast is putting these interfaces into a forwarding state, a Layer 2 loop will form. However, the BPDU Guard optional feature can prevent such a loop from forming.

![PortFast-bpdu](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/49fbc-portfast-bpdu-11.webp?w=1201)


**STP Toolkit BPDU Guard**

If an interface with BPDU Guard enabled receives a BPDU from another switch, the interface will be shut down to prevent a loop from forming.

PortFast speeds up port transition to forwarding state on access ports (typically connecting to end devices). However, PortFast ideally should not receive BPDUs used in STP communication. BPDU Guard listens for BPDUs on PortFast enabled ports.

If BPDU Guard detects a BPDU on a PortFast port, it assumes an issue like an unauthorized device connecting to the switch port. It then disables the port to prevent potential loops and security risks.

You can configure BPDU Guard on a switch interface using the command **spanning-tree bpduguard enable.**

SW1(config)#interface g0/2

SW1(config-if)#spanning-tree bpduguard enable

Similar to PortFast, there is also an option to enable it by default. From global config mode:

SW1(config)#spanning-tree portfast bpduguard default

This enables BPDU guard on all portfast-enabled interfaces.

The following screenshot was taken from Packet Tracer. A switch was connected to a BPDU-guard enabled interface, and now you can see what happens when a BPDU arrives on a BPDU guard-enabled port.

![BPDU-Guard](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/c5546-bpdu-guard-12.webp?w=1201)

The port is disabled, effectively shut down.

To enable a port that was disabled by BPDU guard, use the commands shutdown, and then no shutdown on the interface.

![BPDU-Guard-cli-output](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/5a2e4-bpdu-guard-cli-output-13.webp?w=1201)

The interface comes up.

In terms of Spanning Tree optional features, the CCNA 200-301 exam topics list only mentions PortFast:

2.0 Network Access

2.5 Interpret basic operations of Rapid PVST+ Spanning Tree Protocol

2.5.a Root port, root bridge (primary/secondary), and other port names

2.5.b Port states (forwarding/blocking)

2.5.c PortFast

BPDU Guard has a practical connection to PortFast, so BPDU Guard is likely included.

**STP Toolkit Root Guard/Loop Guard**

There are many other optional features that can be enabled on a switch. Let’s introduce two other optional features in case they show up in the exam, Root Guard and Loop Guard.

1) Root Guard: If a switch receives a superior BPDU (with a lower Bridge ID) than the current root bridge on the Root Guard enabled port, the switch will not accept the new switch as the root bridge. The interface will be disabled. This helps maintain the Spanning Tree topology if someone plugs another switch into the network either with bad intent, or perhaps without knowing the impact of their action.

Configure Root Guard from interface configuration mode: **spanning-tree guard root**

Enable Root Guard on specific ports where you want to enforce the designated root bridge location.

Verify the configuration: **show spanning-tree interface** *interface*

2) Loop Guard: If you enable loop guard on an interface, even if the interface stops receiving BPDUs, it will not start forwarding. The interface will be disabled. This prevents loops that can happen if an interface fails only in one direction, causing what is called a unidirectional link that cannot receive data, but is still able to forward it, or the opposite.

## STP configuration – mode (MST, PVST+, Rapid PVST+)

STP runs by default so you do not actually have to do any configuration, but you should know how to change which switch becomes the root switch to make sure traffic follows the best path.

Let’s look at some basic STP configurations, starting with the mode. You can configure the spanning mode the switch uses with the command **spanning-tree mode.**

![spanning-tree-mode](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/05c1f-spanning-tree-mode-14.webp?w=1201)


We have three options.

MST (Multiple spanning tree), a topic beyond the scope of the CCNA.

PVST is a Cisco proprietary STP version that runs a separate instance of STP for each VLAN. This allows for different root bridges and port roles to be configured for each VLAN.

Rapid PVST is also a Cisco proprietary STP version that runs a separate instance of STP for each VLAN. However, it uses a faster convergence algorithm than PVST, which can help to improve network availability in the event of a failure.

Note: references to PVST are references to PVST+, since PVST per se (which preceded PVST+) is dead and buried. RSTP (rapid STP) is sometimes used to refer to Rapid PVST (i.e., Rapid PVST+).

Modern Cisco switches run Rapid PVST by default, and usually there is no reason to change it.

## STP configuration – root bridge

You can manually configure the root bridge by manipulating the Bridge Priority of a switch. With these MAC addresses and the default priority values, SW1 is the root bridge.

![root-bridge-configuration](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/99cdd-root-bridge-configuration-15.webp?w=1201)


However, we could configure SW3 to be the root bridge. We could also configure SW2 to be a secondary root bridge, which will be next in line to become the root bridge if the current root bridge fails.

Let’s see how to do these configurations. This is how to configure the root bridge, called the primary root bridge: **spanning-tree vlan** *vlan-number* **root primary**.

![spanning-tree-vlan-root-primary](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/a01c0-spanning-tree-vlan-root-primary-16.webp?w=1201)


Note the root ID and Bridge ID matching information, indicating a successful configuration. And it also says “This bridge is the root”.

The **spanning-tree vlan** *vlan-number* **root primary** command (the spanning-tree root command) sets the STP priority to 24576. If another switch already has a priority lower than 24576, the command sets this switch’s priority to 4096 less than the other switch’s priority. So the command makes this switch have the lowest priority, making it the root bridge.

If you then check the running-config, you can see that the command that is actually applied in this case is spanning-tree vlan 1 priority 24576.

![spanning-tree-vlan-priority](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/33781-spanning-tree-vlan-priority-17.webp)

So this command tells the switch to apply the spanning-tree priority command, either with the priority 24576, or 4096 less than the current lowest priority.

The command to set **the secondary root bridge**, the bridge with the second-lowest priority, is basically the same.

![spanning-tree-vlan-root-secondary](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/30475-spanning-tree-vlan-root-secondary-18.webp?w=1201)


The **spanning-tree vlan** *vlan-number* **root secondary** command sets the spanning tree priority for this VLAN to 28672 (24576 + 4096).

However, like the root primary command, the actual command that is applied is the spanning-tree priority command.

![spanning-tree-vlan-priority](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/fca10-spanning-tree-vlan-priority-19.webp)

For both of these commands, you could actually use the spanning-tree priority command as you see here to configure the root bridge. The spanning-tree root command is just a simple way to do it without remembering the different increments of 4096 of the bridge priority.

## STP load balancing

The interface between SW1 and SW2 is disabled because SW1 is blocking its G0/0 interface.

![STP-load-balancing](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/67818-stp-load-balancing-20.webp?w=1201)


This topology is running Cisco’s PVST+, so this is the topology for VLAN1.

Perhaps there is another VLAN, VLAN 2, in this topology. What will the topology look like for it?

It will look like this, the default topology, because the root bridge settings we configured only apply to VLAN 1.

![STP-load-balancing](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/a3e71-stp-load-balancing-21.webp?w=1201)


In VLAN 2, the connection between SW1 and SW2 will not be disabled, but the connection between SW2 and SW3 will be disabled. This allows for Spanning Tree **load balancing**.

If you have multiple VLANs in your network, blocking the same interface in each VLAN is a waste of interface bandwidth. That connection will be sitting idle, just waiting for another connection to fail so it can take over and start forwarding. However, if you configure a different root bridge for different VLANs, different VLANs will disable different interfaces.

To check if you understood that explanation, ponder this. We want to make SW1 the primary root bridge for VLAN10 and the secondary for VLAN20, so essentially it acts like a backup root bridge for VLAN20.

![STP-load-balancing-vlans](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/e3ad8-stp-load-balancing-vlans-22.webp?w=1201)


We can configure SW1 and SW2 using the spanning-tree root commands.

So here are the commands to issue on SW1.

SW1(config)#spanning-tree vlan 10 root primary

SW1(config)#spanning-tree vlan 20 root secondary

On SW2 we want to do the opposite. We want to configure SW2 to be the root bridge for VLAN20 and the secondary root bridge for VLAN10, so SW2 will have the second lowest priority in VLAN10 and become the root for VLAN10 if SW1 fails.

Here are the commands to issue on SW2, basically the opposite of SW1.

SW2(config)#spanning-tree vlan 20 root primary

SW2(config)#spanning-tree vlan 10 root secondary

This way of configuring STP makes it possible to load balance by blocking different ports in each VLAN, in each STP instance. We can use our network bandwidth more effectively since we do not have any connections going totally unused just waiting for another connection to fail.

With those settings, perhaps the VLAN10 topology looks like this.

![STP-load-balancing-vlans](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/07ced-stp-load-balancing-vlans-23.webp?w=1201)


And then perhaps the VLAN20 topology looks like this.

![STP-load-balancing-vlans](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/2ada9-stp-load-balancing-vlans-24.webp?w=1201)


Different connections are used in different VLANs, allowing the load to balance across different interfaces. This is called load balancing.

## Configuring STP port settings

There are two main settings you can configure on a Spanning Tree port: the root cost and the port priority. As you can see from this command they are both configured on a per-VLAN basis like the bridge priority.

![Configuring-STP-port-settings](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/c0f87-configuring-stp-port-settings-25.webp?w=1201)


“cost” is the root cost. Recall from [STP Part 1](https://itnetworkingskills.wordpress.com/2023/03/22/root-bridge-election-root-port-selection/), FastEthernet costs 19, Gigabit Ethernet costs 4, etc. Cost is used to determine the root port, and is also used in selecting designated and non-designated ports.

Recall from STP Part 1, **port priority is the first half of the STP port ID**, which is the final tiebreaker in determining the root port. The STP port ID equals the port priority plus the port number.

You may want to change the root cost or the port priority in order to change the result of the root port or designated port selection process.

The cost and priority are the only spanning tree interface settings you need to know for the CCNA.

First, the cost was configured for this interface. As you can see the range is from 1 to 200 million. Then we set the port priority, which is configured in increments of 32, from 0 to 224.

![spanning-tree-vlan-cost](https://itnetworkingskills.wordpress.com/wp-content/uploads/2024/05/44f65-spanning-tree-vlan-cost-26.webp?w=1201)

## Command review

\>To enable PortFast on a switch:

SW(config-if)# **spanning-tree portfast**  
→to enable PortFast on a switch interface

SW(config)# **spanning-tree portfast default**  
→to enable PortFast on all access ports

\>To configure BPDU Guard on a switch:

SW(config-if)# **spanning-tree bpduguard enable**  
→to configure BPDU Guard on a switch interface

SW(config)# **spanning-tree portfast bpduguard default**  
→to enable BPDU guard on all portfast-enabled interfaces

\>To enable a port that was disabled by BPDU guard:

SW(config-if)# **shutdown**

SW(config-if)# **no shutdown**

\>STP mode (MST, PVST+, Rapid PVST+):

SW(config)# **spanning-tree mode**?  
mst  
pvst  
rapid-pvst

\>Root bridge configuration:

You can manually configure the root bridge by manipulating the (4-bit) bridge priority of a switch.

SW(config)# **spanning-tree vlan** *vlan-number* **root primary**  
→to configure the primary root bridge using the spanning-tree root command. You can check the running-config to see the spanning-tree priority command that was actually applied

SW(config)# **spanning-tree vlan** *vlan-number* **root secondary**  
→to set the secondary root bridge

SW# **show spanning-tree**

SW# **show spanning-tree vlan** *vlan-number*

\>STP load balancing ( **example** ):

The commands to issue on SW1 and SW2 to make SW1 the primary root bridge for VLAN10 and the secondary for VLAN20, and SW2 the primary root bridge for VLAN20 and the secondary for VLAN10:

SW1(config)#spanning-tree vlan 10 root primary  
SW1(config)#spanning-tree vlan 20 root secondary

SW2(config)#spanning-tree vlan 20 root primary  
SW2(config)#spanning-tree vlan 10 root secondary

\>Configuring STP port settings ( **example** ):

There are two main settings you can configure on a Spanning Tree port: the root cost and the port priority (the first half of the port ID, having a default value of 128). They are both configured on a per-VLAN basis like the bridge priority.

The root cost and port priority are the only Spanning Tree interface settings you need to know for the CCNA.

SW2(config-if)#spanning-tree vlan 1?  
cost  
port-priority

SW2(config-if)#spanning-tree vlan 1 cost?  
<1 – 200000000>  
SW2(config-if)#spanning-tree vlan 1 cost 200

SW2(config-if)#spanning-tree vlan 1 port-priority?  
<0 – 224>  
SW2(config-if)#spanning-tree vlan 1 port-priority 32



---
## Rapid Spanning Tree Protocol

One of the challenges of network switching is to avoid loops in the network topology. Loops can cause problems such as broadcast storms, multiple frame copies, and MAC address table instability. To prevent loops, switches use a protocol called **Spanning Tree Protocol (STP)**. STP creates a logical tree structure of the network by blocking some of the redundant links between switches.

STP also detects changes in the network topology and adjusts the tree accordingly. STP has some limitations, such as slow convergence time, low bandwidth utilization, and lack of load balancing. A new protocol called Rapid Spanning Tree Protocol (RSTP) was developed in order to overcome these limitations. It is an enhancement of STP that provides faster and more efficient network switching.

![][https://networklessons.com/wp-content/uploads/2014/10/classic-vs-rapid-spanning-tree-port-states.png]


**The Rapid Spanning Tree Protocol (RSTP) is a network protocol that allows for the rapid recovery of failed links in a network.**

 It is an enhanced version of the Spanning Tree Protocol (STP) that enhances the performance of the spanning tree. Similar to STP, the RSTP protocol can generate a single spanning tree (also known as instance 0). As a result, it is not equipped to consider VLANs in its management of redundant paths.

The enhancements in the performance of RSTP typically make it a better choice than STP in environments that do not involve VLANs. The 802.1w standard is recognized by the Institute of Electrical and Electronics Engineers (IEEE) as the standard for Rapid Spanning Tree Protocol.

### How does RSTP Work?

RSTP complies with a strict set of guidelines that allows switches to determine the optimal method for forwarding network traffic without any unnecessary redundancy. When it is turned on for a network, the spanning tree algorithm will make all of the necessary decisions automatically about the configuration of the spanning tree.

In Rapid Spanning Tree Protocol, the topmost bridge in the network is designated as the Root bridge. Its primary responsibility is to send network topology information to other switches within the network. This plays a critical role in the case of hardware malfunctions or any changes in topology. The optimal alternative routes are established without any delay.

### Why is RSTP important in networking?

It is important in networking because it eliminates network loops by dynamically managing the topology. These network loops can cause broadcast storms in the network and lower network performance.

It also minimizes downtime of the network and ensures seamless communication with its rapid convergence capabilities. This is very important for applications that are mission-critical.

## RSTP Port Roles

RSTP protocol defines four port roles. These are:

#### Root ports

Root Ports are ports that connect to the root bridge, which is the switch with the lowest bridge ID in the network. Root ports are always in a forwarding state and forward all traffic to and from the root bridge.

#### Designated ports

Designated ports are ports that connect to other switches and are responsible for forwarding traffic to and from their segments. Designated ports are also always in a forwarding state and are selected based on the lowest path cost to the root bridge.

#### Alternate ports

Alternate ports are ports that provide an alternative path to the root bridge in case of a failure of a root or designated port. Alternate ports are in a discarding state by default and do not forward any traffic unless they become root or designated ports.

#### Backup ports

Backup ports are ports that provide a redundant link to the same segment as a designated port. Backup ports are also in a discarding state by default and do not forward any traffic unless they become designated ports.

![][https://www.pynetlabs.com/wp-content/uploads/2023/06/RSTP-Port-Roles-1024x597.jpeg]

---

## The Rapid Spanning Tree Port States

It assigns different port states to each port on a bridge, depending on its role and status in the network topology. The port states in RSTP are:

![Port States in RSTP](https://www.pynetlabs.com/wp-content/uploads/2023/06/Port-States-in-RSTP.jpeg)

1. **Discarding:** The port does not forward or receive any data frames. It only listens for BPDU (Bridge Protocol Data Unit) messages that contain information about the network topology. This is the initial state of all ports and the state of non-designated ports.
2. **Learning:** The port learns the MAC (Media Access Control) addresses of the devices connected to it and adds them to its MAC address table. It still does not forward or receive any data frames, but it continues to listen for BPDU messages.
3. **Forwarding:** The port forwards and receives data frames normally. It also learns MAC addresses and listens for BPDU messages. This is the state of designated ports and root ports.

|   |   |
|---|---|
|**STP State (802.1d)**|**RSTP State (802.1w)**|
|Blocking|Discarding|
|Listening|Discarding|
|Learning|Learning|
|forwarding|Forwarding|
|Disabled|Discarding|

**Note:** While the learning state is utilized in Rapid Spanning Tree Protocol, its duration is comparatively short compared to STP.

### RSTP Link Types

RSTP distinguishes between three different ‘link types’.

- **Edge:**

It is a port that is connected to an end host. It moves directly to forwarding without negotiating.

- **Point-to-Point:**

It establishes a direct connection between two switches.

- **Shared:**

It is an established connection to a hub. It should be operated in half-duplex mode.

#### RSTP Timers and their Significance

- **Hello Timer:** It defines the interval between BPDUs.
- **Forward Delay Timer:** It defines the time spent in the learning and forwarding states.
- **Max Age Timer:** It specifies how long the bridge will wait before discarding the outdated BPDU information.

## RSTP vs Other Protocols

##### RSTP vs STP

RSTP has faster convergence as compared to STP. R-STP can converge in a few seconds, while STP takes nearly 50 seconds.

##### RSTP vs MSTP

R-STP is best for smaller networks, while M-STP is great for larger networks as it supports multiple STPs.

### Applications of Rapid Spanning Tree Protocol in Today’s Network

- **Enterprise Networks:** It is used in office networks as it promises uninterrupted operations in office environment networks.
- **Data Centers:** It is also used in today’s data center setups because of its high convergence.

#### Advantages of RSTP

One of the key benefits of using the RSTP over STP is that it reduces the convergence time. In case of any changes in network topology, STP displays convergence time somewhere between 40-50 seconds. In a modern networking environment, there is a high demand for enhanced speed, with a 40-50 seconds latency typically considered unacceptable. In contrast, Rapid Spanning Tree Protocol decreases the time required for convergence, typically to a range of 5 to 10 seconds. Hence, it’s a better option than STP.

Here are some other benefits of RSTP Protocol –

- **Rapid network reconfiguration**: It quickly transitions ports to the forwarding state, minimizing network downtime.
- **Improved network performance**: It maximizes bandwidth utilization and minimizes packet loss.
- **Simple implementation**: It is easy to implement and configure, maintaining a similar logical topology to STP.
- **Scalability**: It supports networks of various sizes, multiple VLANs, and multiple spanning trees (MST) for load balancing and performance improvement.

#### Disadvantages of RSTP

- **Increased resource consumption**: It demands more processing power and memory compared to STP.
- **Potential for suboptimal path selection**: Its fast convergence may lead to less optimal path choices in certain scenarios.
- **Dependency on network hardware**: Its effectiveness relies on the capabilities and implementation of the underlying network equipment.

It’s important to consider these disadvantages alongside the benefits of Rapid Spanning Tree Protocol when evaluating its suitability for a particular network environment.

---

