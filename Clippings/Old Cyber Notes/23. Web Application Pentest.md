
	![COMPLETE][WEB-FUNDAMENTALS]


Web application penetration testing is the practice of simulating attacks on a system in an attempt to gain access to sensitive data, with the purpose of determining whether a system is secure. These attacks are performed either internally or externally on a system, and they help provide information about the target system, identify vulnerabilities within them, and uncover exploits that could actually compromise the system.

There are several key benefits to incorporating web application penetration testing into a security program.  

- **It helps you satisfy compliance requirements.** Pen testing is explicitly required in some industries, and performing web application pen testing helps meet this requirement.
  
- **It helps you assess your infrastructure.** Infrastructure, like firewalls and DNS servers, is public-facing. Any changes made to the infrastructure can make a system vulnerable. Web application pen testing helps identify real-world attacks that could succeed at accessing these systems.
  
- **It identifies vulnerabilities.** Web application pen testing identifies loopholes in applications or vulnerable routes in infrastructure—before an attacker does.
  
- **It helps confirm security policies**. Web application pen testing assesses existing security policies for any weaknesses.
  
**Web application penetration testing is comprised of four main steps including:**

1. Information gathering.
2. Research and exploitation.
3. Reporting and recommendations.
4. Remediation with ongoing support.

These tests are performed primarily to maintain secure software code development throughout its lifecycle.

Coding mistakes, specific requirements, or lack of knowledge in cyber attack vectors are the main purpose of performing this type of penetration test.


## Web Application Vulnerabilities

Web application vulnerabilities involve a system flaw or weakness in a web-based application. They have been around for years, largely due to not validating or sanitizing form inputs, misconfigured web servers, and application design flaws, and they can be exploited to compromise the application’s security.

### 1. SQL Injection Attacks

SQL injection attacks allow attackers to spoof identity, tamper with existing data, cause repudiation issues such as voiding transactions or changing balances, allow the complete disclosure of all data on the system, destroy the data or make it otherwise unavailable, and become administrators of the database server.

Structured Query Language (SQL) is now so commonly used to manage and direct information on applications that hackers have come up with ways to slip their own SQL commands into the database.

These commands may change, steal or delete data, and they may also allow the hacker access to the root system. 

### Types of SQL Injection (SQLi)

#### In-band SQLi (Classic SQLi)

In-band SQL Injection is the most common and easy-to-exploit of SQL Injection attacks. In-band SQL Injection occurs when an attacker is able to use the same communication channel to both launch the attack and gather results.

The two most common types of in-band SQL Injection are Error-based SQLi and Union-based SQLi.

#### Error-based SQLi

Error-based SQLi is an in-band SQL Injection technique that relies on error messages thrown by the database server to obtain information about the structure of the database. In some cases, error-based SQL injection alone is enough for an attacker to enumerate an entire database. While errors are very useful during the development phase of a web application, they should be disabled on a live site, or logged to a file with restricted access instead.

#### Union-based SQLi

Union-based SQLi is an in-band SQL injection technique that leverages the UNION SQL operator to combine the results of two or more SELECT statements into a single result which is then returned as part of the HTTP response.

#### Inferential SQLi (Blind SQLi)

Inferential SQL Injection, unlike in-band SQLi, may take longer for an attacker to exploit, however, it is just as dangerous as any other form of SQL Injection. In an inferential SQLi attack, no data is actually transferred via the web application and the attacker would not be able to see the result of an attack in-band (which is why such attacks are commonly referred to as “blind SQL Injection attacks”). Instead, an attacker is able to reconstruct the database structure by sending payloads, observing the web application’s response and the resulting behavior of the database server.

The two types of inferential SQL Injection are Blind-boolean-based SQLi and Blind-time-based SQLi.

#### Boolean-based (content-based) Blind SQLi

Boolean-based SQL Injection is an inferential SQL Injection technique that relies on sending an SQL query to the database which forces the application to return a different result depending on whether the query returns a TRUE or FALSE result.

Depending on the result, the content within the HTTP response will change, or remain the same. This allows an attacker to infer if the payload used returned true or false, even though no data from the database is returned. This attack is typically slow (especially on large databases) since an attacker would need to enumerate a database, character by character.

#### Time-based Blind SQLi

Time-based SQL Injection is an inferential SQL Injection technique that relies on sending an SQL query to the database which forces the database to wait for a specified amount of time (in seconds) before responding. The response time will indicate to the attacker whether the result of the query is TRUE or FALSE.

Depending on the result, an HTTP response will be returned with a delay, or returned immediately. This allows an attacker to infer if the payload used returned true or false, even though no data from the database is returned. This attack is typically slow (especially on large databases) since an attacker would need to enumerate a database character by character.

#### Out-of-band SQLi

Out-of-band SQL Injection is not very common, mostly because it depends on features being enabled on the database server being used by the web application. Out-of-band SQL Injection occurs when an attacker is unable to use the same channel to launch the attack and gather results.

Out-of-band techniques, offer an attacker an alternative to inferential time-based techniques, especially if the server responses are not very stable (making an inferential time-based attack unreliable).

Out-of-band SQLi techniques would rely on the database server’s ability to make DNS or HTTP requests to deliver data to an attacker. Such is the case with Microsoft SQL Server’s xp_dirtree command, which can be used to make DNS requests to a server an attacker controls; as well as Oracle Database’s UTL_HTTP package, which can be used to send HTTP requests from SQL and PL/SQL to a server an attacker controls.

### 2. Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a web security vulnerability that allows attackers to inject malicious scripts into legitimate websites, potentially compromising user interactions and data.

This attack also involves injecting malicious code into a website or web-based app. However, in this case the malicious code the attacker has injected only runs in the user's browser when they visit the attacked website, and it goes after the visitor directly.

An attacker sends on input JavaScript tags to your web application. When this input is returned to the user unsanitized, the user’s browser would execute it.

### Types of XSS

#### Stored XSS (Persistent XSS)

The most damaging type of XSS vulnerability is Stored XSS (Persistent XSS). An attacker uses Stored XSS to inject malicious content (referred to as the payload), most often JavaScript code, into the target application. If there is no input validation, this malicious code is permanently stored (persisted) by the target application, for example within a database. For example, an attacker may enter a malicious script into a user input field such as a blog comment field or in a forum post.

When a victim opens the affected web page in a browser, the XSS attack payload is served to the victim’s browser as part of the HTML code (just like a legitimate comment would). This means that victims will end up executing the malicious script once the page is viewed in their browser.

#### Reflected XSS (Non-persistent XSS)

The second and the most common type of XSS is Reflected XSS (Non-persistent XSS). In this case, the attacker’s payload has to be a part of the request that is sent to the web server. It is then reflected back in such a way that the HTTP response includes the payload from the HTTP request. Attackers use malicious links, phishing emails, and other social engineering techniques to lure the victim into making a request to the server. The reflected XSS payload is then executed in the user’s browser.

Reflected XSS is not a persistent attack, so the attacker needs to deliver the payload to each victim. These attacks are often made using social networks.

#### DOM-based XSS

DOM-based XSS is an advanced XSS attack. It is possible if the web application’s client-side scripts write data provided by the user to the Document Object Model (DOM). The data is subsequently read from the DOM by the web application and outputted to the browser. If the data is incorrectly handled, an attacker can inject a payload, which will be stored as part of the DOM and executed when the data is read back from the DOM.

A DOM-based XSS attack is often a client-side attack and the malicious payload is never sent to the server. This makes it even more difficult to detect for Web Application Firewalls (WAFs) and security engineers who analyze server logs because they will never even see the attack. DOM objects that are most often manipulated include the URL (document.URL), the anchor part of the URL (`location.hash`), and the Referrer (`document.referrer`).



### 3. Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF), also known as XSRF, is a web security vulnerability where a malicious website, email, or application tricks a user into performing actions on a trusted site without their knowledge or consent.

In the case of CSRF, a third-party site uses your browser, cookies, and session to issue a request to a target site (e.g., your bank). If on one browser tab you are logged in to your bank, and if your bank is vulnerable to this type of attack, then another tab can be controlled to make your browser misuse its credentials on the attacker’s behalf.

### 4. Command Injection

Command injections occur when user input is not properly validated before being integrated into functions that execute system commands. If an application accepts data from users without filtering it, an attacker can hijack the initial command and execute arbitrary commands.

To bypass the intended command, it is possible to use special characters that act as command separators, allowing the original context to be removed and other commands to be executed. The main command separators on Windows and Unix systems include:` &, &&, | or ||`.


#### 1. Arbitrary Command Injection

Arbitrary command injection occurs when an application is vulnerable to a malicious command entered by a user that has the potential to execute any command directly on the underlying host. The attacker may be able to gain access to sensitive data using this type of attack. 

#### 2. Arbitrary File Uploads

When users are allowed to upload files with arbitrary file extensions, command injection can occur when these files are stored in the web root.  

#### 3. Server-Side Template Injection

Server-side template injection is possible when web applications employ server-side templating technologies to produce dynamic HTML responses. When user input is integrated with a template in an unsafe manner, SSTI vulnerabilities exist, resulting in remote code execution on the server. 

#### 4. Insecure Serialization

Other vulnerabilities, such as improper deserialization, can be used to execute arbitrary commands in addition to the conventional command injection vulnerabilities. This is because the server-side code deserializes the user-supplied serialized material without verifying it.  

Although this is often called the insecure serialization class of vulnerabilities, if the target program fits specific conditions, such as having proper gadgets in the classpath, it eventually leads to command injection.

---

## Zed Attack Proxy (ZAP)

ZAP is short for "Zed Attack Proxy", which is leveraged by many testers to find security vulnerabilities in web applications, understand and fix security issues, and maintain long-term security hygiene by creating a baseline security assessment of a web application.

### How to Use  ZAP for Security Penetration Testing

#### 1. Install ZAP

The first step in our penetration testing guide is [downloading](https://www.zaproxy.org/download/) the latest version from the OWASP ZAP website for your operating system to install ZAP or reference the [ZAP docs](https://www.zaproxy.org/docs/) for a more detailed installation guide.

![](https://entail.jit.io/en-assets/jit/fit-in/680x521/6320ad6815338eea687e0f76_image4-1694627942604.png)

Once completed, follow the prompts to install OWASP ZAP on your machine.

#### 2. Persist a Session

**Persisting a session means that the session will be saved and can be reopened at a later time.** This is useful if you want to continue testing a website or application at a later time.

Once you’ve started the application, you'll see this screen:

![](https://entail.jit.io/en-assets/jit/fit-in/680x743/6320ad92bf178f9c45d18613_image9-1694627939564.png)

The prompt gives two options to persist in the session. **You can use the default to name the session based on the current timestamp or set your name and location.**

Alternatively, you can persist a session by going to ‘File’ and choosing ‘Persist Session…’. Give your session a name and click ‘Save’.



![description of gif](https://assets-global.website-files.com/61ec6c60334fc97ddd2b6dda/6320adaccb3754eccecba239_image3.gif)

#### 3. Run an Automated Scan

Running an automated scan is a way to check for common security vulnerabilities in web applications without manually initiating the analysis. This is done by sending requests to the application and analyzing the responses for signs of common vulnerabilities. It can help to find security issues early in the development process before they are exploited.

With OWASP ZAP, you can use a ZAP spider or the AJAX spider. So what’s the difference?

ZAP spider is a web crawler that can **automatically find security vulnerabilities in web applications**. Meanwhile, the AJAX spider is a web crawler designed to crawl and **attack AJAX-based web applications.**

Clicking on the ‘Tools’ option will give you a list of available penetration testing tools provided by OWASP ZAP. 

![description of gif](https://assets-global.website-files.com/61ec6c60334fc97ddd2b6dda/6320adc5768cef0a6e303f49_image1.gif)

To run an automated scan, you can use the quick start “Automated Scan” option under the “Quick Start” tab. Enter the URL of the site you want to scan in the “URL to attack” field, and then click “Attack!”.

﻿

![description of gif](https://assets-global.website-files.com/61ec6c60334fc97ddd2b6dda/6320ade9b27a2333f97f2338_image7.gif)

#### 4. Interpret Test Results

Interpreting test results in OWASP ZAP is vital to understand the scan findings and determine which issues require further investigation. Additionally, it can help to prioritize remediation efforts.

You can view alerts by clicking on the 'Alerts' tab. This tab will show you a list of all the alerts that have been triggered during your testing, sorted by risk level, with the highest risk alerts at the top of the list. You can also see details of the discovered vulnerabilities and suggestions on how you can fix them.

﻿

![description of gif](https://assets-global.website-files.com/61ec6c60334fc97ddd2b6dda/6320ae174f6e4b2aa1a7a0bf_image5.gif)

#### 5. View Alerts and Alert Details

Viewing alerts and alert details in OWASP ZAP is a way to see what potential security issues have been identified on a website. It can help security and administrators understand what needs to be fixed to improve the app's security. 

If you can't find your ‘Alerts’ tab, you can access it via the ‘View’ menu along with other options. Once you have your ‘Alerts’ tab, you can navigate the various vulnerabilities discovered and explore the relevant reports.

![description of gif](https://assets-global.website-files.com/61ec6c60334fc97ddd2b6dda/6320ae27c947a97a4b5731dd_image2.gif)

#### 6. Explore an Application Manually

Exploring an application manually in OWASP ZAP is a process of manually testing the application for security vulnerabilities. 

To explore an application manually, select 'Manual Explore.' Select your browser, which will launch a proxy in your browser. Here, you will be given penetration testing tools such as spiders, and if a vulnerability is discovered, an alert flag will be added to the alerts panel.

---

## Burp Suite

Burp or Burp Suite is a graphical tool for testing Web application security. The tool is written in Java and developed by PortSwigger Web Security. It is developed by the company named Portswigger.

Burpsuite is a collection of tools bundled into a single suite made for Web Application Security or Penetration testing. It’s a java executable and hence it’s cross-platform. 

Kali Linux comes with a Burp Suite free edition installed. Burp Suite is an integrated platform for performing security testing of web applications. 

Its various tools work seamlessly together to support the entire testing process, from initial mapping and analysis of an application’s attack surface to finding and exploiting security vulnerabilities.

Burpsuite can be used as a basic HTTP proxy to intercept traffic for analysis and playback, a web application security scanner, a tool to perform automated attacks against a web application, a tool to spider an entire website to identify attack surface and a has a plugin API with a ton of third-party addons available. It is the most popular tool among professional web app security researchers and bug bounty hunters. Its ease of use makes it a more suitable choice over free alternatives like OWASP ZAP.


> **User interface Walkthrough on Additional Notes**

### Different Burp Suite Editions

Burp Suite is currently available in three editions

- Community — This is a free version, which is by default installed in Kali Linux.
- Professional — This is a paid edition. it costs around $399/year.
- Enterprise — This edition is meant for enterprises. It costs around $3999/year.

#### Configuring Burp suite

1. Go to the “Proxy” tab, then the “Options” sub-tab, and look in the “Proxy Listeners” section.
2. You should see an entry in the table with the checkbox ticked in the Running column, and “127.0.0.1:8080” showing in the Interface column.
3. You will need to select the table entry, click “Edit”, and change the port number of the listener to a different number.

![][https://miro.medium.com/v2/resize:fit:720/format:webp/1*u1Yd6jVit76_qOk-_-Iobg.png]


#### Configuring your Browser to work with Burp

Open Firefox and go to the Customize menu.  
In the Customize menu, select Options, then click on “Settings” in the Network Section.

![](https://miro.medium.com/v2/resize:fit:700/1*OoL2j_21GjQj_xvNFgyCUA.png)

![](https://miro.medium.com/v2/resize:fit:700/1*62Yd-frrsa2QUST3OGnjHQ.png)

This will open the relevant configuration options for your host computer.  
Now select Manual proxy configuration and enter the same HTTP Proxy and Port number that is entered on Burp suite.  
Click on “OK” to save the settings.

***SSL Certificates***  
If we went now and tried to go to a site configured with SSL (eg google.com) we would get an invalid ssl cert error,  
So, following: [https://support.portswigger.net/customer/portal/articles/1783075-installing-burp-s-ca-certificate-in-your-browser](https://support.portswigger.net/customer/portal/articles/1783075-installing-burp-s-ca-certificate-in-your-browser) we will install burp’s CA in our browser.  
• goto [http://burp](http://burp/) in firefox  
• click on ‘CA Certificate’ in the top menu bar

![](https://miro.medium.com/v2/resize:fit:592/1*ZRUmPA8Y_d33dVN9_WDVpA.png)

• click ‘save’  
• Goto Firefox > Click on Options from side menu > Write Certificates in the search field

![](https://miro.medium.com/v2/resize:fit:700/1*ZayZ1KJUAW5IWWKIKWKR6Q.png)

• click on “View Certificates” > authorities > import

![](https://miro.medium.com/v2/resize:fit:655/1*PbcWHm_nO21rcC8dnJB4oA.png)

• browse to where you downloaded the CA bundle.  
• Tick all the options.  
• click “OK”  
• In the addressbar in firefox, enter “google.com” and switch over to burpsuite.  
You may have a few captures for ‘firefox profile tracing’ — you can drop those by clicking the ‘drop’ button

![](https://miro.medium.com/v2/resize:fit:700/1*tzsIsPL2BOmbqCn8psBMgg.png)

In the burpsuite tabs you can see the http headers, http parameters and the hex values if you need to (similar to the firefox inspector, but prior to the request being filled by the server)  
• at this point, nothing has been sent to the remote server!  
• click ‘forward’  
• the request is sent to the server  
• You now have to switch to the ‘http history tab’

#### Configuring an Mobile Device to Work With Burp

 **Android:**

1. Connect to the same **Wi-Fi network** as your computer.
2. Open **Wi-Fi Settings** → Tap on your connected network.
3. Scroll down and select **Advanced** (or **Modify Network**).
4. Change **Proxy Settings** to **Manual**.
5. Enter:
    - **Proxy Hostname**: Your **computer’s IP address** (e.g., `192.168.1.100`).
    - **Proxy Port**: `8080` (or the port set in Burp).
6. Save the settings.

---

**iOS (iPhone/iPad):**

1. Go to **Settings → Wi-Fi**.
2. Tap your **Wi-Fi network**.
3. Scroll to **HTTP Proxy**, select **Manual**.
4. Set:
    - **Server**: Your **computer’s IP** (e.g., `192.168.1.100`).
    - **Port**: `8080`.
5. Leave **Authentication** disabled.

---

#### Install Burp CA Certificate on Mobile Device

- Download the from burp website certificate (`cacert.der`).
- Go to **Settings → Profile Downloaded** → Install.
- After installation, go to:
    - **Settings → General → About → Certificate Trust Settings**.
    - Enable **Full Trust for the Burp Suite CA**.
﻿
---



	![TRYHACKME ROOM][# Web Hacking Fundamentals]