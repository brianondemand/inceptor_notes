## The Internet

The Internet is a vast network that connects computers all over the world. (Network Of Networks)

Through the Internet, people can share information and communicate from anywhere with an Internet connection.

It's important to realize that the Internet is a global network of physical cables, which can include copper telephone wires, TV cables, and fiber optic cables. Even wireless connections like Wi-Fi and 3G/4G rely on these physical cables to access the Internet.

The **World Wide Web**—usually called the Web for short—is a collection of different websites you can access through the Internet. 

A **website** is made up of related text, images, and other resources.

Once you are connected to the Internet, you can access and view websites using a type of application called a web browser.

When you visit a website, your computer sends a request over these wires to a server. A server is where websites are stored, and it works a lot like your computer's hard drive. Once the request arrives, the server retrieves the website and sends the correct data back to your computer.

### Origin Of The Internet

The internet originated in the late 1960s with ARPANET, a U.S. Defense project designed to enable reliable communication through decentralized, packet-switched networks. Its development laid the groundwork for modern internet protocols, leading to public access in the 1990s.

### How do computers communicate

**Internet protocols (IP)** are a set of rules that allow computers and other devices to communicate over the Internet. These protocols ensure that data is sent, received, and understood correctly between different systems. 

**IP Routing** : Process of forwarding IP packets from source to destination.

An IP address is a unique identifier assigned to a device or domain that connects to the Internet. Each IP address is a series of characters, such as '192.168.1.1'.

We have two types of IP addresses: IPv4 &. IPv6

IP packets are created by adding an IP header to each packet of data before it is sent on its way. An IP header is just a series of bits (ones and zeros), and it records several pieces of information about the packet, including the sending and receiving IP address. IP headers also report:

- Header length

- Packet length

- **Time to live (TTL)**, or the number of network hops a packet can make before it is discarded

- Which transport protocol is being used (TCP, UDP, etc.)

![][https://media.geeksforgeeks.org/wp-content/uploads/20241209114045111342/How-does-IP-addressing-work.webp]

---
## IP - The Internet Protocol

IP networks can be broken into different sections, often called subnets. This is accomplished by adding an extra piece of information, together with the IP address, called a _netmask_. The netmask dictates how large a network is and which packet is routed within the network and which should be routed outside of the network.

Netmasks can be represented via decimal numbers or with a slash notation.  When using slash notation, the slash follows the systems IP address. Here are some examples:

|   |   |   |
|---|---|---|
|**IP Address**|**Slash Notation**|**Netmask**|
|10.0.0.1|/8   - Example: 10.0.0.1/8|255.0.0.0|
|172.16.1.1|/12 - Example: 172.16.1.1/12|255.240.0.0|
|192.168.0.1|/16 - Example: 192.168.0.1/16|255.255.0.0|
|192.168.0.1|/24 - Example: 192.168.0.1/24|255.255.255.0|

Some IP networks are reserved for only a certain kind of traffic. The IP addresses in the table above are reserved for only internal organizational use, meaning they should not be routed on the Internet. These kinds of IP addresses are commonly referred to as RFC1918 addresses.

## Different Networks

Let us take a look at different networks within RFC1918 and how large the networks are:

- 10.0.0.0/8 - More than 16 million IP addresses
- 172.16.0.0/12 - About 1 million IP addresses
- 192.168.0.0/16 - 65534 IP addresses

IP segments can be further broken up into smaller and more granular networks.

Each network has a reserved address for broadcasting traffic to every host in the network, this is called the broadcast address. Broadcasting data means sending data to everyone on the network instead of sending to just a single host. There are many applications and protocols which rely on broadcasting traffic in order for them to work.

For each network segment the broadcast is always last IP address in the network. For example in the network 192.168.0.0/24 network, the broadcast address is 192.168.0.255.

The smallest netmask possible is 255.255.255.255, represented as /32. This network only has one IP address.

If traffic needs to be sent back to the host, e.g. for communications between applications, it is sent to the localhost address. This address is always 127.0.0.1 and is a /8 network.

In IP networks the traffic is routed by a router. A router is a networking device which understands the IP format and can forward packets between networks. This is different than a switch as the switch forwards data within a network, while the router forwards between networks.


Packets on the network has headers which describe many of the important details we already discussed within the IP protocol. IPv4 Header looks like this:

![IP Header][https://blog.apnic.net/wp-content/uploads/2018/06/IPv4-header_banner-555x202.png?v=34cd313a983443804b87e60fbb3543224f8e9835f844ee3fbd2e1462a4fff0af]

---

The Source Address is the IP address of the system who is sending the packet, and destination is to whom the packet is intended. There are also other fields in the header which is used by the many features of the IP protocol, but which are outside the scope of this introduction class.

You can check your IP address on Windows by running the command `ipconfig` within a Command Line Window. On Linux this is done with the `ip addr show` or `ifconfig` command.

When a computer needs to communicate to something which can not be found on the LAN, it sends traffic to the default gateway as per how the system is configured. The default gateway being a router which is capable of forwarding the traffic to the destination IP address.

---

## NAT ("Network Address Translation")

NAT allows a system accepting connections on a public IP address to map those requests to an internal RFC 1918 IP address or vice versa. Systems which do NAT'ing are typically firewalls and routers.

A typical implementation of NAT is where the external IP address is used as a front for multiple internal IP addresses, and the destination port number is used to decide which server the data should be sent to. This allows internal IP addresses to receive traffic from external systems.

![NAT Port](https://i0.wp.com/ottverse.com/wp-content/uploads/2021/05/nat-2.jpg?resize=778%2C449&ssl=1)

---


Another very common implementation is allowing internal IP addresses to access the internet with an external IP address. The NAT keeps track of connections from internal to destination addresses and forwards traffic across the connections.

NAT can be configured in many ways, but in this class you we do not go into more details of the method.

**Note**: NAT allows network engineers to be more flexible with their deployments, allowing many different use-cases to unfold.

---

## IPv6 - IP Version 6

IP version 6 is the latest standard for IP and was made to support more IP addresses. Instead of using 32 bits of addressing for IP addresses, 128 bits is used. This allows for enough IP addresses for the foreseeable future while IPv4 has already run out.

IPv6 addresses uses 8 groups of of 4 hexadecimal numbers. An IPv6 address look like this: 2a00:1450:400f:80a::200e:. Notice it does not have have the 8 groups of 4 hexadecimal numbers. This is because IPv6 addresses can be shortened via simple rules:

- Leading 0's can be shortened
- Double colon (::) can be used to represent a continuous string of 0's.

The expanded IPv6 address is: 2a00:1450:400f:080a:0000:0000:0000:200e.

The localhost can be reduced into ::1 and ::.

IPv6 has networks, i.e. subnets, just like IPv4 has.

The IPv6 header looks like this:

![IPv6 Header](https://ghost.menandmice.com/content/images/2021/02/500px-IPv4_Header.svg-1.png)

---

We can see a much simpler header with a lot more room for IP addressing.

IPv6 is used more and more, and there is built in support for this protocol in many tools. For example with `ping` we can switch between IPv4 and IPv6 with the -4 and -6 flag respectively.

Run `ipconfig` and see if you see any IPv6 addresses. If you have IPv6 enabled, try `ping -6 google.com` and `ping -4 google.com`. See how the command allows us to use either IPv4 or IPv6?

Note: If you do not have IPv6 today, there are many public cloud services which will grant you a public IPv6 address today which you can use to experiment and explore with.

---
## Traceroute

Tracerouting is a way to determine which routers are involved in sending a packet from system A to B. Knowing which routers our packets take can be useful both better understanding our networks and also in understanding the attack surface.

A router is responsible for routing the package in the right direction. Imagine this as driving on a road, where road signs at intersections guide you to the destination. These signs at intersections  represent routers. Traceroute identify these signs and intersections and tells you how far away they are, measured in milliseconds (ms).

The IPv4 TTL and IPv6 Hop Limit headers have the same function. Every router who routes a packet will decrement this value by 1, and if the value reaches 0 the router will discard the packet and return an ICMP Time Exceeded packet to the sender.

To perform a traceroute on Windows:

```
tracert google.com
```

To perform a traceroute on Linux (not installed by default):

```
traceroute google.com
```

The process of tracerouting via these tools is simple:

1. The operating system sends a packet google.com, the TTL value is set to 1.
2. The packet is routed on the network, and the first router decrements the TTL by 1, leaving it at 0. This causes the router to drop the packet and send "ICMP Time Exceeded" back to the source.
3. The client increases the TTL 1, allowing the packet to be routed through one additional hop.

This process is repeated, increasing the TTL with 1 until the destination has been reached.

----
### DNS

The **Domain Name System (DNS)** is the phonebook of the Internet.

DNS lets users connect to websites using domain names instead of IP addresses.

Humans access information online through domain names, like nytimes.com or espn.com. Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.

The Authoritative Name Server is the DNS server which is responsible for giving the definitive answer to a question. For example the IP address of google.com will be answered by their authoritative name server, and we can see this server by querying for it:

Finding authoritative name server on Windows:

```
nslookup -type=SOA google.com
```

Finding authoritative name server on Linux:

```
dig -t SOA google.com
```


### There are 4 DNS servers involved in loading a webpage:

1. **The DNS recursor** is a server designed to receive queries from client machines through applications such as web browsers.

2. **The Root Server** is the first step in translating (resolving) human readable host names into IP addresses.

3. **The Top Level Domain Server (TLD)**  is the next step in the search for a specific IP address, and it hosts the last portion of a hostname (In example.com, the TLD server is “com”).


4. **The Authoritative Nameserver** is the last stop in the nameserver query. If the authoritative name server has access to the requested record, it will return the IP address for the requested hostname back to the DNS Recursor that made the initial request.


#### What's the difference between a DNS server and a recursive DNS resolver?

A **DNS server** is a general term for any server that stores and responds to DNS queries by providing information like IP addresses for domain names. It includes authoritative DNS servers, which have definitive information about specific domains.

A **recursive DNS resolver**, on the other hand, acts as an intermediary that queries multiple DNS servers on behalf of a client to resolve a domain name into an IP address. It starts with the root DNS servers and works its way down to find the answer, caching results to speed up future queries.

In short, the **purpose** of a DNS server is to store or provide specific DNS data, while the **purpose** of a recursive resolver is to retrieve that data on behalf of the user.

---

## DHCP ("Dynamic Host Configuration Protocol")

As the name implies, the DHCP protocol allows any system on a network to reach out to a server and receive a configuration. Such configuration typically implies receiving IP address and network range, default gateway and DNS servers.

DHCP allows for easy management of clients joining and leaving a network.

If you are curious if you are using DHCP right now you can type `ipconfig /all` on a Windows system and look for "DHCP Enabled: Yes" in the output. Your computer might have multiple network interfaces

---

## VPN ("Virtual Private Network")

A VPN is a system which enables two system to establish encrypted forms for communication, enabling network traffic to be encrypted in transit. Many VPN's is a client to server architecture, allowing the client to access multiple services behind the VPN. VPN's hosted by your work place is also likely to provide access to resources otherwise only accessible from the inside.

Some VPN services are designed for user privacy and encryption for data in transit. These services enables users to send network data via the VPN, effectively masquerading the users IP address when navigating the Internet.

It is generally good practice to use VPN's to secure your network communications, however we should not use any kind of VPN service. Free VPN services can sometimes be malicious, inspecting, reading and storing your sensitive data.

---
## Reference Models

Network reference models provide standardized frameworks for understanding and designing communication systems.

The OSI model has seven layers, from the physical layer (handling hardware transmission) to the application layer (enabling user interaction).

The TCP/IP model, more practical and widely used, has four layers: network interface, internet, transport, and application.

By organizing functions into layers, these models ensure interoperability, simplify troubleshooting, and facilitate the development of protocols and technologies.

![][https://miro.medium.com/v2/resize:fit:1358/1*7yPBGx_K8GymgeGfzhfznA.gif]

---

## The OSI Model

The OSI ("Open Systems Interconnection") model represents an easy and intuitive way to standardize the different parts required to communicate across networks.

The model makes it clear what is required to communicate on a network by splitting the requirements into multiple layers.

This is what the OSI Model looks like:

|Layer|What it does|
|---|---|
|7 - Application|Where humans process data and information|
|6 - Presentation|Ensures data is in a usable format|
|5 - Session|Capable of maintaining connections|
|4 - Transport|Data is forwarded to a service capable of handling requests|
|3 - Network Layer|Responsible for which path packets should travel on a network|
|2 - Data Link|Responsible for which physical devices packets should go to|
|1 - Physical|The physical infrastructure to transport data|

The top 3 layers are typically implemented in software within the Operating System:

|Layer|Where it is implemented|
|---|---|
|7 - Application|Software|
|6 - Presentation|Software|
|5 - Session|Software|

The bottom 3 layers are typically implemented in hardware within devices on the network, e.g. Switches, Routers and Firewalls:

|Layer|Where it is implemented|
|---|---|
|3 - Network Layer|Hardware|
|2 - Data Link|Hardware|
|1 - Physical|Hardware|

Layer 4, the Transport layer, connects the software with the hardware layers.

SDN ("Software Defined Networking") is technology which allows more layers of the hardware to be implemented via software.

---

## Layer 7 - Application Layer

The business logic and functionality of the application lies here. This is what the users use to interact with services across a network. Most developers create applications on the Application Layer.

Most of the applications you use are on the Application Layer, with the complexity of the other layers hidden.

Examples of Layer 7 Applications:

- HTTP ("Hypertext Transfer Protocol") - Enables us to access web applications
- FTP ("File Transfer Protocol") - Allows users to transfer files
- SNMP ("Simple Network Management Protocol") - Protocol to read and update network device configurations

There are many applications which uses these protocols like Google Chrome, Microsoft Skype and FileZilla.

You are accessing this class via Layer 7!

---

## Layer 6 - Presentation Layer

Typically an unseen layer, but is responsible of adapting, transforming and translating data. This is to ensure the application and layers beneath can understand one another.

- Encoding Schemes used to represent text and data, for example ASCII(American Standard Code for Information Interchange) and UTF(Unicode Transformation Format).
- Encryption for services, for example SSL ("Secure Sockets Layer") and TLS ("Transport Security Layer")
- Compression, for example GZip in use in many implementations of HTTP.

---

## Layer 5 - Session Layer

 This layer's responsibility is handling connections between the application and the layers below. It involves establishing, maintaining and terminating connections, otherwise referred to as sessions.

Common protocols which represent the Session Layer well are:

- SOCKS - A protocol for sending packets through a proxy server.
- NetBIOS - An older Windows protocol for establishing sessions and resolving names.
- SIP ("Session Initiation Protocol") - For engaging in VOIP ("Voice Over IP") communications

---

## Layer 4 - Transport

The layer which allows applications to be represented on the network.

Some well known applications on this layer:

- TCP ("Transmission Control Protocol") - Used for many applications, ensuring stability, control of how much data can be sent at any given time, reliability and more.
- UDP ("User Datagram Protocol") - Lightweight and quick protocol use for many services.
- QUIC ("Quick UDP Internet Connections") - A protocol designed for faster connections and goes hand-in-hand with the version 2 of the HTTP protocol.

---

## Layer 3 - Network

A layer responsible of routing packets between networks via routers.

On this layer, the following protocols reside:

- IP ("Internet Protocol") - Used everyday when accessing the Internet. Comes in two versions, IP version 4 and 6.
- ICMP ("Internet Control Message Protocol") - Used by network devices and network operators, to diagnose network connections or for devices to send and respond to error conditions and more.
- IPSec ("Internet Protocol Security") - Allows encrypted and secure connections between two network devices.

---

## Layer 2 - Link

Link networks, as the name implies, consist of protocols designed to send packets through the actual links (physical connections) that network nodes are connected to. A simpler way of thinking of it is that the Link Layer is responsible for moving data from physical over to logical (to the network layer).

Protocols on this layer include:

- Ethernet - An essential protocol used by most operating systems when connecting to networks using a physical cable.
- Wi-Fi ("Wireless Fidelity") - For accessing networks via radio signals. It uses a family of protocols called IEEE 802.11.xx
- NDP ("Neighbor Discovery Protocol") - IP version 6(IPv6) uses this protocol on the Link Layer to gather information required to communicate via IPv6

---

## Layer 1 - Physical

Physical layer represents the signaling which allows bits and bytes to transfer between a physical medium. It can be transferred via radio or signals over a cable, using electrical signals or light, for example fiber.

Examples of the Physical Layer protocols includes:

- CAN Bus ("Controller Area Network") - Used in microcontrollers and other devices to communicate to other similar devices, not involving a computer. Often used in ICS ("Industrial Control Systems").
- Ethernet Physical Layer - Used by Ethernet on the physical layer to send signals with speeds up to many gigabits of traffic per second.
- Bluetooth Physical Layer - Bluetooth also has its own specifications on how radio signals should be sent and received.

---

1. **Practical Section** 

- Wireshark Introduction.
- Check types of protocals.

---

## In-Depth Transport and Link Layers

Computer systems often needs to talk to other systems; this is done by putting them on the same network. Several different technologies are in place to enable computers to talk over different kinds of networks. In this section we will go deeper into the protocols which are used in most networks.

The networks we are using consists of multiple protocols, some which are featured in this class. There are also many other protocols in use in networks, all which have the potential of having security risks associated with them.

---

## TCP ("Transmission Control Protocol")

Just like IP uses IP addresses for addressing, TCP and UDP uses ports. A port, as indicated with a number between 0 and 65535, dictates which network service should process the request. 

In the picture below we can see a TCP packet and how it would look like for anyone inspecting traffic on the network.

![TCP Header](https://www.w3schools.com/cybersecurity/img_tcp-header.png)

We can see the graphic showing 16 bits for both source and destination ports, this is the same for for UDP. The Sequence and Acknowledgement numbers are used in the three-way handshake and to reliably transfer data. We can also see the control bits used to indicate what kind of packet it is. The other headers also play an important part, but outside of the security course.

---

## TCP 3-Way-Handshake

TCP uses a three-way handshake to allow two systems to engage in communications. The handshake uses 32 bits of PRNG ("Pseudo Random Number Generator") numbers to establish the handshake. The handshake enforces that both parties intends to communicate.

Here is a graphic to illustrate:

![TCP Handshake](https://media.geeksforgeeks.org/wp-content/uploads/handshake-1.png)

---

Explanation on how TCP engages in communications:

1. Client initiates the communication by sending a packet with the control bit SYN set in the header, a PRNG number in the Sequence number field and a target destination port. The Network Layer (Layer 3) allows the packet to be sent to a remote system. This packet is referred to as a SYN packet.

2. Server receives the packet, reads the Sequence Number from the Client and crafts a response. The response sets the Acknowledgement field with the Sequencer number of the client with the number 1 added to it. Furthermore the response contains the controls bits SYN and ACK set and the Sequence number is set to the Servers PRNG number. This packet is referred to as a SYN/ACK packet.

3. The Client receives the SYN-ACK packet and to complete the handshake returns a packet with the ACK control bit set. The final packet also confirms the PRNG number from the Server by returning it in the Acknowledgement field of the header.

This process is commonly referred to as the SYN, SYN/ACK, ACK 3-way handshake.

In the following picture we can see two hosts performing the 3-way handshake: 

![Handshake in Wireshark](https://www.w3schools.com/cybersecurity/img_wireshark-handshake-1.png)

The screenshot shows the tool Wireshark being used to capture and inspect packets. Wireshark is a very good utility because it allows us to visualize packets and inspect them more in-depth. The screenshot shows 3 packets representing the 3-way handshake. Notice the source and destination columns representing the two parties communicating. The Info field shows source and destination port, including (within the square brackets) the SYN, SYN/ACK and ACK. 

The next screenshot shows data being communicated between the parties after the 3-way handshake. The data inside of the TCP packet has been highlighted near the bottom of the picture. 

![TCP Data](https://www.w3schools.com/cybersecurity/img_tcp-data.png)

A message to W3School students is shown in the screenshot above. Can you see it?

---

## UDP ("User Datagram Protocol")

UDP is used for traffic which does not need the resilience and security of TCP, typically applications such as VOIP, but in the modern world more applications are using UDP to support fast packet transfer with resiliency and security built into the higher levels of the OSI model; QUIC is an example of this.

Looking at the UDP Header we can see the same Source and Destination ports in use, but no Sequence numbers or Control bits. The protocol has much less overhead, leading to faster transmission of data.

![UDP Header](https://www.w3schools.com/cybersecurity/img_udp-header.png)

Because UDP does not have features such as the 3-Way-Handshake, UDP can be easily spoofed.

---

## Switched Networks

Systems are connected to a LAN ("Local Area Network") through a Switch. Switches uses MAC ("Media Access Control") addresses for addressing, not the more well-known IP address. Switches forward traffic across Local Area Networks, i.e. your home-network or within branches of your organization. MAC Addresses are designed to be unique, but anyone can change their MAC Address as long as they have administrator rights.

The MAC address defined by 6 octets, for example: FC:F8:AE:12:34:56

The first three octets represent the organization which manufactured the device communicating, called OUI ("Organizational Unique Identifier"). The above MAC address is assigned to Intel Corporate. You can search for MAC Addresses in many places.

The last three octets is determined by the manufacturer.


---
## Address Resolution Protocol (ARP) 

It is a network protocol used to determine the MAC address (hardware address) from any IP address.

So, the goal is to find out the MAC address of where we want to talk to. That’s where ARP comes in handy. It helps by turning the IP address into the physical MAC address, so we can chat with other devices on the network.


#### How Does It Work?

When a new computer joins a local area network (LAN), it will receive a unique IP address to use for identification and communication. 

Packets of data arrive at a gateway, destined for a particular host machine. 

The gateway, or the piece of hardware on a network that allows data to flow from one network to another, asks the ARP program to find a **MAC address** that matches the IP address. 

The **ARP cache** keeps a list of each IP address and its matching MAC address. 

The ARP cache is dynamic, but users on a network can also configure a static ARP table containing IP addresses and MAC addresses.

![][https://www.fortinet.com/content/dam/fortinet/images/cyberglossary/what-is-arp.jpg]

---

```
arp
```

```
arp -a
```

Checking ARP table

```
arp -an
```

Show ip instead of domain names

## Types Of ARP

 **Proxy ARP**

Proxy ARP is a technique by which a proxy device on a given network answers the ARP request for an IP address that is not on that network. The proxy is aware of the location of the traffic's destination and offers its own MAC address as the destination. 

 **Gratuitous ARP**

Gratuitous ARP is almost like an administrative procedure, carried out as a way for a host on a network to simply announce or update its IP-to-MAC address. Gratuitous ARP is not prompted by an ARP request to translate an IP address to a MAC address.

**Reverse ARP (RARP)**

Host machines that do not know their own IP address can use the Reverse Address Resolution Protocol (RARP) for discovery.

**Inverse ARP (IARP)**

Whereas ARP uses an IP address to find a MAC address, IARP uses a MAC address to find an IP address.

## ARP Attacks


**ARP spoofing**

ARP spoofing is also known as ARP poison routing or ARP cache poisoning. This is a type of malicious attack in which a cyber criminal sends fake ARP messages to a target LAN with the intention of linking their MAC address with the IP address of a legitimate device or server within the network. The link allows for data from the victim's computer to be sent to the attacker's computer instead of the original destination.


**Man-in-the-Middle (MTM) Attacks**

A man-in-the-middle (MITM) attack is a type of eavesdropping in which the cyberattacker intercepts, relays, and alters messages between two parties—who have no idea that a third party is involved—to steal information.

**Denial-of-Service Attacks**

A denial-of-service (DoS) attack is one in which a cyberattacker attempts to overwhelm systems, servers, and networks with traffic to prevent users from accessing them. A larger-scale DoS attack is known as a distributed denial-of-service (DDoS) attack, where a much larger number of sources are used to flood a system with traffic.

---

## Internet Control Message Protocol (ICMP)

The Internet Control Message Protocol (ICMP) is a protocol that devices within a network use to communicate problems with data transmission.

 One of the primary ways in which ICMP is used is to determine if data is getting to its destination and at the right time. 
 
 This makes ICMP an important aspect of the error reporting process and testing to see how well a network is transmitting data.

Both traceroute and ping use ICMP. Traceroute and ping are messages sent regarding whether data was successfully transmitted. 

When traceroute is used, the devices that a packet of data went through to get to its destination are displayed in the report. This includes the physical routers that handled the data.

The traceroute also tells you how much time it took for the data to go from one device to another. Each time data goes between routers, the trip is referred to as a hop. The information revealed by the traceroute can be used to figure out which devices along the route are causing delays.

A ping is similar to a traceroute but simpler. It reports how long it takes for data to go between two points. ICMP facilitates ping in that the ICMP echo request and echo reply are used during the ping process.

ICMP is also used to hurt network performance. This is done using an ICMP flood, a Smurf attack, and a ping of death attacks that overwhelms a device on the network and prevent normal functionality.

## How Is ICMP Used In DDoS Attacks?

In a DDoS attack, ICMP is commonly used in a few different ways: through an ICMP flood attack, a ping of death attack, or a Smurf attack.

### ICMP flood attack

In an ICMP flood attack, the attacker tries to send so many pings that the device being targeted cannot handle all the ICMP echo request packets. Because each packet requires processing and a response, this drains the device’s resources, preventing legitimate users from being served by the device.

### Ping of death

A Ping-of-Death attack involves an attacker sending an extremely large ping to a device that cannot handle pings of that size. The machine may then crash or freeze up. The packet of data is fragmented as it heads toward the target, but during the reassembly process, it is put back together. When it reaches the target, there is a buffer overflow, causing the device to malfunction. Ping-of-death attacks are more of a danger for older equipment within the network.

### Smurf attack

In a Smurf attack, the attacker transmits an ICMP packet that has a spoofed or faked IP address. When the equipment on the network replies, each reply gets sent to the spoofed IP address, and the target is flooded with a ton of ICMP packets. This kind of attack is also typically only a problem for older equipment.


---
## VLAN ("Virtual LAN")

VLAN, often called Private VLAN's, is a way for a Switch to embed tags (or a VLAN ID) within the Frame. Multiple Switches can then make sure that computer systems on the LAN can only communicate to certain other systems, i.e. other systems on with the same VLAN ID.

---

# Web Applications

Web Applications are integral to almost everything we do, whether it is to access the Internet or to remotely control your lawnmower. In this introduction class we will cover the basics of web application security.

---

## The HTTP protocol

HTTP is the carrier protocol which allows our browsers and applications to receive content such as HTML ("Hyper Text Markup Language"), CSS ("Cascading Style Sheets"), images and videos.

---

## URLs, Query Parameters and Scheme

To access a web application we use a URL ("Uniform Resource Locator").

The URL to google.com contains a domain, a script being accessed and Query Parameters.

The script we are accessing is called /search. The / indicates it is contained in the top directory on the server where files are being served. The ? indicates the input parameters to the script and the & delimits different input parameters. In our URL the input parameters are:

- q with a value of w3schools cyber security
- ie with a value of UTF-8

The meaning of these inputs is up to the webservers application to determine.

Sometimes you will see just / or /? indicating that a script has been setup to serve to respond to this address. Typically this script is something like an index file which catches all requests unless a specific script is specified.

The Scheme is what defined the protocol to use. In our case it is the first part of the URL: https. When the scheme is not defined in the URL it allows the application to decide what to use. Schemes can include an entire array of protocols such as:

- HTTP
- HTTPS
- FTP
- SSH
- SMB

---

## HTTP Headers

The HTTP protocol uses many headers, some custom to the application and others well defined and accepted by the technology.

Example request to http://google.com

```javascript
GET /search?q=w3schools+cyber+security&ie=UTF-8 HTTP/1.1  
Host: google.com  
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36  
Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8  
Referer: https://google.com/  
Accept-Encoding: gzip, deflate  
Cookie: cookie1=value1;cookie2=value2  
```

The request header specifies what the client wants to perform on the target webserver. It also has information regarding if it accepts compression, what kind of client is accessing and any cookies the server has told the client to present. The HTTP request headers are explained here:

| Header                         | Explanation                                                                                                                                                       |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GET /search... HTTP/1.1        | GET is the verb we are using to access the application. Explained in detail in the section HTTP Verbs. We also see the path and query parameters and HTTP version |
| Host: google.com               | This header indicates the target service we want to use. A server can have multiple services as explained in the section on VHOSTS.                               |
| User-Agent                     | A client application, that is the browser in most cases, can identify itself with the version, engine and operating system                                        |
| Accept                         | Defines which content the client can accept                                                                                                                       |
| Referer: (google.com/)         | If the client clicked a link from a different website the Referer header is used to say from where the client came from                                           |
| Accept-Encoding: gzip, deflate | Can the content be compressed or encoded? This defines what we can accept                                                                                         |
| Cookie                         | Cookies are values sent by the server in previous requests which the client sends back in every subsequent request. Explained in detail in the section State      |

With this request, the server will reply with headers and content. Example headers are seen below:

```javascript
HTTP/1.1 200 OK  
Content-Type: text/html  
Set-Cookie: <cookie value>  
<website content>
```

The response header and content is what determines what we will see in our browser. The HTTP response headers are explained as following:

|Header|Explanation|
|---|---|
|HTTP/1.1 200 OK|The HTTP Response code. Explained in detail in the HTTP Response Codes section|
|Content-Type: text/html|Specifies the type of content being returned, e.g. HTML, JSON or XML|
|Set-Cookie:|Any special values the client should remember and return in the next request|

---

## HTTP Verbs

When accessing a web application the client is instructed on how to send data to the web application. There are many verbs which can be accepted by the application.

|!Verb|Used for|
|---|---|
|GET|Typically used to retrieve values via Query Parameters|
|POST|Used to send data to a script via values in the body of the Request sent to the webserver. Typically it involves creating, uploading or sending large quantities of data|
|PUT|Often use to upload or write data to the webserver|
|DELETE|Indicate a resource which should be deleted|
|PATCH|Can be used to update a resource with a new value|

These are used as the web application requires. Restful (REST) web services are especially good at using the full array of HTTP Verbs to define what should be done on the backend.

---

## HTTP Response Codes

The application running on the webserver can respond with different codes based on what occurred on the server side. Listed are common response codes the webserver will issue to the client which security professionals should know about:

|Code|Explanation|
|---|---|
|200|Application returned normally|
|301|Server asks client to permanently remember a redirect to a new location where the client should access|
|302|Redirect temporarily. Client doesn't need to save this reply|
|400|The client made an invalid request|
|403|The client is not allowed to access this resource. Authorization is required|
|404|The client tried to access a resource which does not exist|
|500|The server errored in trying to fulfill the request|

---

## REST

Rest services, sometimes called RESTful services, employ the full force of HTTP Verbs and HTTP Response Codes to facilitate the use of the web application. RESTful services often uses parts of the URL as a query parameter to determine what happens on the web application. REST is typically used by API's ("Application Programming Interfaces").

REST URLs will invoke functionality based on the different elements of the URL.

An example REST URL: http://example.com/users/search/w3schools

This URL will invoke functionality as part of the URL instead of Query Parameters. We can decipher the URL as:

|Parameter|Comment|
|---|---|
|users|Accessing the users part of the functionality|
|search|Accessing the search feature|
|w3schools|The user to search for|

---

## Sessions & State

There is no built in way for a server to identify a returning visitor in HTTP. For a webserver to identify the user, a secret value must be communicated to and from the Client in each request. This is typically done via Cookies in headers, however other ways are also common such as via GET and POST parameters or other headers. Passing state via GET parameters is not recommended as such parameters are often logged on the server or in intermediaries such as a proxy.

![HTTP Sessions](https://www.w3schools.com/cybersecurity/img_http-sessions.svg)

Here are some common Cookie examples which allows the application on the webserver to control sessions and state:

- PHPSESSID
- JSESSIONID
- ASP.NET_SessionID

These values represent a certain state, often called a session, on the server. This state represents things like:

- What user you have logged in as
- Privileges and authorizations

It is important that session value, sent to the Client, can not be easily guessed or otherwise identified by others. If they could, an attacker could then present themselves as other users on the web application.

State can also be saved on the client. This involves the server sending all the states to the client and relies on the client sending back all the items. Such implementations relies on encryption to check the integrity of the state the client is claiming. Examples of implementations using this is listed below:

- JWT ("JSON Web Tokens")
- ASP.Net ViewState

You are using cookies to take this class! You can inspect these cookies in your web browser by opening up the developer tools. This is done by hitting `F12` within the browser, opening up the developer tools window. Within this window you should be able to find the correct place where your cookies are stored. 

![Developer Console](https://www.w3schools.com/cybersecurity/img_web-developerconsole-cookies.png)

In Google Chrome, the cookies were identified in the Application tab above. 

**Note**: Can you think of why the cookies have been masked away in the screenshot so you cannot read them?

---

## Virtual Hosts

One webserver can process many applications via Virtual Hosts, often abbreviated as Vhosts. To facilitate access to other Virtual Hosts the web server typically reads off the Host header of the client request, and based on this value sends the request to the correct application.

---

## URL Encoding

For an application to safely transfer content between the server and client, some characters must be encoded to ensure they do not impact the protocol. To preserve the integrity of the communications, URL encoding is used.

URL Encoding replaces unsafe characters with a % and two hexadecimal digits. For example:

- Percentage is replaced with %25
- Space is replaced with %20
- Quote is replaced with %22

An excellent tool to perform text analysis and run operations such as URL Decoding is CyberChef. 

```
**Note**: 

Play around with Cyber Chef and see if you can reveal what the following message in URL encoded characters hold: 

%48 %65 %6c %6c %6f %20 %64 %65 %61 %72 %20 %77 %33 %73 %63 %68 %6f %6f %6c %73 %20 %73 %74 %75 %64 %65 %6e %74 %2e %20 %48 %6f %70 %65 %20 %79 %6f %75 %20 %61 %72 %65 %20 %6c %65 %61 %72 %6e %69 %6e %67 %20 %73 %6f %6d %65 %74 %68 %69 %6e %67 %20 %74 %6f %64 %61 %79 %21
```

---

## JavaScript

To support dynamic content, browsers use the scripting language JavaScript. This enables developers to program solutions which will run on the client, enabling more interactive and "alive" web-content.

JavaScript is also involved in many attacks against web-applications and client applications such as browsers.


---


## Encryption with TLS

The HTTP protocol does not support encryption for data-in-transit, hence a wrapper around HTTP is added for encryption support. This is indicated with a S following HTTP, i.e. HTTPS.

The encryption used to be SSL ("Secure Sockets Layer"), but has since been deprecated. Instead TLS ("Transport Layer Security") is typically used to enforce encryption.

---

## Hypertext Transfer Protocol Secure (HTTPS)

Hypertext transfer protocol secure (HTTPS) is the secure version of HTTP, which is the primary protocol used to send data between a web browser and a website. 

The main difference between HTTP and HTTPS is that HTTPS has the additional SSL/TLS layer to ensure all data being transferred is encrypted and secure. The security provided by HTTPS is essential for sites that send sensitive information, such as credit card information or billing addresses.

![](https://www.fortinet.com/content/dam/fortinet/images/cyberglossary/http-vs-https.jpg)

---

## How does HTTPS work?

HTTPS uses an encryption protocol to encrypt communications. The protocol is called Transport Layer Security (TLS), although formerly it was known as Secure Sockets Layer (SSL). This protocol secures communications by using what’s known as an asymmetric public key infrastructure. 

This type of security system uses two different keys to encrypt communications between two parties:

1. The private key - this key is controlled by the owner of a website and it’s kept, as the reader may have speculated, private. This key lives on a web server and is used to decrypt information encrypted by the public key.
2. The public key - this key is available to everyone who wants to interact with the server in a way that’s secure. Information that’s encrypted by the public key can only be decrypted by the private key.


HTTPS uses port 443. This differentiates HTTPS from HTTP, which uses port 80.

Many website hosting providers and other services will offer TLS/SSL certificates for a fee. These certificates will be often be shared amongst many customers.