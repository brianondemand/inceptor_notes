Docker Compose is a tool that allows you to define and run multi-container Docker applications. With Compose, you use a YAML file to configure your application's services, networks, and volumes, then create and start all the services with a single command.


Managing multiple containers manually is tedious. **Docker Compose** simplifies this by defining services in a `docker-compose.yml` file.

### Example Workflow:

1. Define services (frontend, backend, database).
    
2. Specify ports, volumes, and environment variables.
    
3. Run everything with one command: `docker-compose up`.


###  Docker Compose Watch

- Automatically watches for changes in files and updates containers.
- Types of actions: `sync` (copy changed files), `rebuild` (rebuild image), `sync+restart` (do both).
- Improves developer experience by reflecting code changes in real-time without manual rebuilding.

## Core Concepts

### docker-compose.yml

The heart of Docker Compose is the `docker-compose.yml` file, which defines your entire application stack:

```yaml
version: '3'
services:
  web:
    build: ./web
    ports:
      - "5000:5000"
    depends_on:
      - db
  db:
    image: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: example

volumes:
  postgres_data:
```

### Key Components

1. **Services**: Individual containers that make up your application
2. **Networks**: How containers communicate with each other
3. **Volumes**: Persistent data storage
4. **Environment variables**: Configuration for containers
5. **Dependencies**: Order of startup and connections between services

## Basic Commands

```bash
# Start all services defined in docker-compose.yml
docker-compose up

# Run in detached mode (background)
docker-compose up -d

# Stop all services
docker-compose down

# Stop services and remove volumes
docker-compose down -v

# View logs
docker-compose logs

# Follow logs of specific service
docker-compose logs -f web

# Execute command in running container
docker-compose exec web bash

# Check status of services
docker-compose ps

# Build or rebuild services
docker-compose build
```

## Common Configurations

### Service Configuration

```yaml
services:
  web:
    # Build from Dockerfile in current directory
    build: .
    
    # Or specify build context and Dockerfile
    build:
      context: ./dir
      dockerfile: Dockerfile.dev
      args:
        buildvar: value
    
    # Expose ports (HOST:CONTAINER)
    ports:
      - "8000:8000"
    
    # Mount volumes (HOST:CONTAINER)
    volumes:
      - ./code:/code
      - data_volume:/var/data
    
    # Environment variables
    environment:
      - DEBUG=True
      - SECRET_KEY=dev
    
    # Or use env_file
    env_file:
      - ./.env
    
    # Set resource limits
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 500M
    
    # Restart policy
    restart: unless-stopped
    
    # Define networks to join
    networks:
      - frontend
      - backend
    
    # Wait for other services
    depends_on:
      - db
      - redis
```

### Networks

```yaml
services:
  web:
    networks:
      - frontend
  
  api:
    networks:
      - frontend
      - backend
  
  db:
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  
  backend:
    driver: bridge
    internal: true  # Not accessible from outside
```

### Volumes

```yaml
services:
  db:
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:
    driver: local
    # Optional driver options
    driver_opts:
      type: 'none'
      o: 'bind'
      device: '/path/on/host'
```

## Development vs. Production

Docker Compose can use multiple files to vary configuration between environments:

**Base configuration** (`docker-compose.yml`):

```yaml
services:
  web:
    build: .
    depends_on:
      - db
  db:
    image: postgres
```

**Development overrides** (`docker-compose.override.yml` - applied automatically):

```yaml
services:
  web:
    volumes:
      - ./:/code
    ports:
      - "8000:8000"
    environment:
      - DEBUG=True
```

**Production overrides** (`docker-compose.prod.yml`):

```yaml
services:
  web:
    restart: always
    environment:
      - DEBUG=False
    ports:
      - "80:8000"
```

Run with:

```bash
# Development (uses docker-compose.yml + docker-compose.override.yml)
docker-compose up

# Production
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

## Advanced Features

### Profiles

Profiles let you selectively start services:

```yaml
services:
  app:
    build: .
  
  db:
    image: postgres
  
  dev-tools:
    image: development-tools
    profiles:
      - dev
```

Run with:

```bash
# Only start app and db
docker-compose up

# Include dev-tools
docker-compose --profile dev up
```

### Extending Services

Use YAML anchors and aliases to share configurations:

```yaml
x-common-config: &common-config
  restart: always
  logging:
    driver: "json-file"
    options:
      max-size: "10m"
      max-file: "3"

services:
  web:
    <<: *common-config
    image: nginx
  
  api:
    <<: *common-config
    image: my-api
```

### Health Checks

Monitor service health and control dependency order:

```yaml
services:
  web:
    image: nginx
    depends_on:
      db:
        condition: service_healthy
  
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
```

## Real-World Example

Here's a more complete example of a web application with frontend, backend, and database:

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    environment:
      - REACT_APP_API_URL=http://localhost:5000/api
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/app
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgres://postgres:password@db:5432/app
    depends_on:
      db:
        condition: service_healthy

  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=app
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:

networks:
  default:
    driver: bridge
```

Docker Compose is perfect for:

- Local development environments
- Automated testing in CI/CD pipelines
- Simple deployments of multi-container applications
- Proof of concept and prototyping

It's a powerful tool that brings order to the complexity of multi-container applications and makes development and deployment significantly more manageable.