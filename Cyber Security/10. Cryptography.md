
Encryption is essentially important because it secures data and information from unauthorized access and thus maintains confidentiality.

### Key Terms 

**Ciphertext** - The result of encrypting a plaintext, encrypted data

**Cipher** - A method of encrypting or decrypting data. Modern ciphers are cryptographic, but there are many non cryptographic ciphers like Caesar.

**Plaintext** - Data before encryption, often text but not always. Could be a photograph or other file

**Encryption** - Transforming data into ciphertext, using a cipher.

**Encoding** - NOT a form of encryption, just a form of data representation like base64. 

**Key** - Some information that is needed to correctly decrypt the ciphertext and obtain the plaintext.

**Passphrase** - Separate to the key, a passphrase is similar to a password and used to protect a key.

**Asymmetric encryption** - Uses different keys to encrypt and decrypt.

**Symmetric encryption** - Uses the same key to encrypt and decrypt

**Brute force** - Attacking cryptography by trying every different password or every different key

**Cryptanalysis** - Attacking cryptography by finding a weakness in the underlying maths


**Algorithm** - Algorithms are the rules or instructions for the encryption process.

 **Key exchange** - Key exchange is the method used to share cryptographic keys between a sender and their recipient.

### What Is Cryptography?

**Cryptography is the practice and study of techniques for securing communication and data in the presence of adversaries.**

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*uQKUmkGy8VdZTb8MnFWrcQ.png)


### Principles Of Cryptography

- **Confidentiality:** Information can only be accessed by the person for whom it is intended and no other person except him can access it.

- **Integrity:** Information cannot be modified in storage or transition between sender and intended receiver without any addition to information being detected.

- **Non-repudiation:** The creator/sender of information cannot deny his intention to send information at a later stage.

- **Authentication:** The identities of the sender and receiver are confirmed. As well destination/origin of the information is confirmed.

- **Interoperability:** Cryptography allows for secure communication between different systems and platforms.

- **Adaptability:** Cryptography continuously evolves to stay ahead of security threats and technological advancements.


## Types of Cryptography

Cryptography can be categorized into two types:

1. **Classic Cryptography:** It refers to the historical methods and techniques of [encryption](http://encryption/) used before the advent of computers and modern cryptographic algorithms. It can be divided into subtypes, including:

- **Caesar Cipher:** A substitution cipher in which each letter is shifted to a fixed number of positions.
  
- **Vigenere Cipher:** A polyalphabetic substitution cipher that uses multiple Caesar ciphers based on a keyword.
  
- **Playfair Cipher:** A substitution cipher that uses a 5x5 matrix of letters to encrypt pairs of letters.
  
- **Rail Fence Cipher:** A transposition cipher that writes the message in a zigzag pattern.
  
- **Transposition Cipher:** Rearranges characters to encrypt plaintext messages.
  
- **Atbash Cipher:** Substitutes each letter with its reverse alphabet counterpart.

**2. Modern Cryptography:** It refers to the cryptographic algorithms and techniques developed since the mid-20th century with the advancements in computing technology. It can be divided into subtypes, including:

- **Symmetric Key Cryptography:** Utilizes a single secret key for both encryption and decryption, such as AES.
  
- **Asymmetric Key Cryptography:** Utilizes key pairs (public and private keys) for encryption and decryption, like RSA.
  
- **Hash Functions:** Generate fixed-size hash values to verify integrity and create digital signatures.
  
- [Digital Signatures](https://infosec-train.blogspot.com/2022/12/what-is-digital-signature.html)**:** Provide authentication and integrity using asymmetric encryption and hash functions.
  
- **Key Exchange Algorithms:** Enable secure key exchange over insecure channels, such as Diffie-Hellman and ECDH.

----
## Cryptography Techniques

### Encryption Algorithms

Encryption is a process that converts readable data (plaintext) into an unreadable format (ciphertext), making it secure from unauthorized access. 

**Key Concepts:**

**Plaintext**: The original, readable data.

**Ciphertext**: The encrypted, unreadable data.

**Key**: A secret code used to encrypt and decrypt data. 

Cryptography is broadly classified into two categories: ***Symmetric key Cryptography*** and ***Asymmetric key Cryptography*** (popularly known as public key cryptography).

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*-ZubnDvcxP7cy8JUgUX4Eg.png)


### How various Cryptographic Algorithms Works?

Let’s start with the Symmetric key encryption

#### Symmetric Key Cryptography

> An **encryption** system in which the sender and receiver of a message share a single, common **key** that is used to encrypt and decrypt the message. The most popular **symmetric** – **key** system is the Data **Encryption** Standard (DES).

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*1zgMNGVF1fRjwJxRKI5Wvg.png)

#### Transposition Ciphers

> In Cryptography, a transposition cipher is a method of encryption by which the positions held by units of plaintext (which are commonly characters or groups of characters) are shifted according to a regular system, so that the ciphertext constitutes a permutation of the plaintext.

That is, the order of the units is changed (the plaintext is reordered). Mathematically, a bijective function is used on the characters’ positions to encrypt and an inverse function to decrypt.

***Example:***

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*PcZi89bNwU2oird8UQ90dw.png)

#### Substitution Cipher

> Method of encryption by which units of plaintext are replaced with ciphertext, according to a fixed system; the “units” may be single letters (the most common), pairs of letters, triplets of letters, mixtures of the above, and so forth.

***Example:***

Consider this example shown on the slide: Using the system just discussed, the keyword “zebras” gives us the following alphabets:

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*Pt0ZgOYMA1pXwtUVTrtgdQ.png)

#### Stream Cipher

> Symmetric or secret-key encryption algorithm that encrypts a single bit at a time. With a Stream Cipher, the same plaintext bit or byte will encrypt to a different bit or byte every time it is encrypted.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*nsXiNh0zM7LwoOQe0e8bUA.png)

#### Block Cipher

> An encryption method that applies a deterministic algorithm along with a symmetric key to encrypt a block of text, rather than encrypting one bit at a time as in stream ciphers

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*5r-ePZOfkohw_c3reTYPgw.png)

***Example:*** A common block cipher, AES, encrypts 128-bit blocks with a key of predetermined length: 128, 192, or 256 bits. Block ciphers are pseudorandom permutation (PRP) families that operate on the fixed size block of bits. PRPs are functions that cannot be differentiated from completely random permutations and thus, are considered reliable until proven unreliable.


### Asymmetric Key Encryption (or Public Key Cryptography)

The encryption process where different keys are used for encrypting and decrypting the information. Keys are different but are mathematically related, such that retrieving the plain text by decrypting ciphertext is feasible.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*GjT-QXp9iAaXdj3HrzOX3A.png)

RSA is the most widely used form of public key encryption,

### RSA Algorithm

- RSA stands for *Rivest, Shamir, and Adelman*, inventors of this technique
- Both public and private key are interchangeable
- Variable Key Size (512, 1024, or 2048 bits)

*Here’s how keys are generated in RSA algorithm*

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*Zc1M84hbfFCE1fp8iNA8-A.png)

Alright, this was it for “What is Cryptography” article. To safeguard your information and data shared over the internet it is important to use strong encryption algorithms, to avoid any catastrophic situations.

---

## Practical 

#### 1. Generate a Symmetric Key

**Command:**

```bash
openssl rand -out symmetric.key 32
```

**Options:**

- rand: Generates random bytes.
  
- -out symmetric.key: Saves output to symmetric.key.
  
- 32: Number of bytes to generate (32 bytes = 256 bits for AES-256).

---

#### 2. Encrypt Files Using Symmetric Encryption

**Command:**

```bash
openssl enc -aes-256-cbc -salt -in plaintext.txt -out encrypted-text.txt -pass file:symmetric.key
```

**Options:**

- enc: Encrypt utility.
  
- -aes-256-cbc: Algorithm used (AES-256 in CBC mode).
  
- -salt: Adds salt to encryption.
  
- -in plaintext.txt: Input file.
  
- -out encrypted.sym: Output file.
  
- -pass file: symmetric.key: Use key from file.

---

#### 3. Decrypt Files Using Symmetric Encryption

**Command:**

```bash
openssl enc -d -aes-256-cbc -in encrypted-text.txt -out decrypted.txt -pass file:symmetric.key
```

**Options:**

- -d: Decrypt mode.
  
- Other options same as encryption.


---

**View the Symmetric Key**

```bash
xxd symmetric.key
```

Show Key in Hexadecimal format.


---

#### Generate an Asymmetric RSA Key Pair


#### Generate Private Key:

**Command:**

```bash
openssl genrsa -out private_key.pem 2048
```

**Options:**

- -genras: Command to generate a private key using RSA algorithm.
  
- -out private-key.pem: Saves private key.
  
- 2048: Sets RSA key size to 2048 bits.

---

#### 2. Extract Public Key:

**Command:**

```bash
openssl rsa -in private-key.pem -out public-key.pem -outform PEM -pubout
```

Options:

- rsa: RSA utility.
  
- -in private-key.pem: Input private key.
  
- -outform PEM : Save key in PEM format
  
- -pubout: Output the public key.
  
- -out public-key.pem: Save the public key.

---



#### 3. Encrypt Files using Asymmetric Keys

Command:

```bash
openssl rsautl -encrypt -inkey public-key.pem -pubin -in plaintext.txt -out encrypted.asym
```

Options:

- rsautl: RSA encryption/decryption utility.
  
- -encrypt: Mode for encryption.
  
- -inkey public.key: Use public key.
  
- -pubin: Treat the key as a public key.
  
- -in plaintext.txt: Input file.
  
- -out encrypted.asym: Output file.

---

#### 4. Decrypting Files using Asymmetric Keys


**Command:**

```bash
openssl rsautl -decrypt -inkey private-key.pem -in encrypted-text.txt -out decrypted-text.txt
```

**Options:**

- rsautl: RSA encryption/decryption utility.

- -decrypt: Decryption mode.
  
- -inkey private.key: Use private key.
  
- -in encrypted.asym: Encrypted file.
  
- -out decrypted.txt: Output file.


----
## Hash Functions

A hash function is a mathematical algorithm that takes an input (or 'message') and returns a fixed-size string of bytes. The output is typically a sequence of seemingly random characters called a hash value, message digest, or simply a digest.

Unlike encryption, hashing is a one-way function. This means that once data has been hashed, you cannot derive the original input from the hash. This one-way nature makes hash functions ideal for verifying data integrity and storing passwords securely.


#### Purpose of Hashing in Cryptography

Hash functions serve several purposes in cryptographic systems:

- Data Integrity: To ensure that data has not been altered. If the hash of the original data matches the hash of the received data, the data is presumed intact.

- Password Storage: Systems store the hash of passwords, not the passwords themselves. When a user logs in, the system hashes the entered password and compares it with the stored hash.

- Digital Signatures: Involves hashing a message before signing it with a private key to ensure both authenticity and integrity.

- Message Authentication Codes (MACs): Hash functions form part of HMACs, which are used to authenticate messages.


#### Properties of a Good Cryptographic Hash Function

To be cryptographically secure, a hash function must satisfy these core properties:

**a.) Deterministic**

Given the same input, it always produces the same hash output.

**b.) Fast Computation**

It should be able to compute the hash value quickly.

**c.) Pre-image Resistance**

Given a hash output, it should be computationally infeasible to find an input that hashes to that output. This protects against recovering the original data.

**d.) Second Pre-image Resistance**

Given input A and its hash, it should be infeasible to find a different input B (B ≠ A) such that hash(B) = hash(A).

**e.) Collision Resistance**

It should be hard to find any two different inputs that produce the same hash output. A collision breaks the integrity of the hash function.

**f.) Avalanche Effect**

A small change in the input should result in a significantly different hash.

---

## Popular Hash Algorithms


#### MD5 (Message Digest 5)

**MD5**, developed by Ronald Rivest in 1991, was one of the first hash algorithms to gain widespread adoption. It was designed to produce a 128-bit hash value, typically represented as a 32-character hexadecimal number. Its primary purpose was to verify data integrity, and it was commonly used in software downloads to ensure that files weren’t corrupted or tampered with.

For example, you might download a software installer and see an MD5 checksum published alongside it. You’d then run a tool to compute the MD5 hash of your downloaded file and compare it to the given checksum. If they matched, you could assume the file hadn’t been altered.

However, over time, researchers discovered serious vulnerabilities in MD5. In 2004, the first practical collision was demonstrated. A **collision** occurs when two different inputs produce the same hash output. This is extremely dangerous in cryptographic contexts. By 2008, techniques had advanced to the point where attackers could generate collisions quickly and inexpensively, undermining the security of any system using MD5 for things like digital signatures or certificates.

As a result, MD5 is now considered **cryptographically broken** and is deprecated for all security-sensitive applications. It is still used in non-security contexts (e.g., basic checksumming), but it is no longer trusted in any system requiring true data security.

---

#### SHA-1 (Secure Hash Algorithm 1)

SHA-1 was developed by the U.S. National Security Agency (NSA) and published by the National Institute of Standards and Technology (NIST) in 1995. Like MD5, it was designed for integrity verification but produces a slightly longer hash — 160 bits instead of MD5’s 128.

For years, SHA-1 was the standard for cryptographic hashing in secure protocols like SSL/TLS, PGP, and Git. You could think of it as the industry’s go-to hashing tool in the early 2000s. It was widely embedded in software libraries, hardware devices, and digital certificate systems.

However, it too fell victim to advances in cryptanalysis. Around 2005, weaknesses in SHA-1’s internal structure were discovered that made theoretical collision attacks possible. In 2017, Google and CWI Amsterdam announced the **SHAttered attack**, the first practical collision for SHA-1 using real-world files (specifically, two PDF files that had the same SHA-1 hash). This was a watershed moment that proved SHA-1 was no longer secure in practice, not just in theory.

Today, SHA-1 is deprecated in all major standards and protocols. Most web browsers and certificate authorities no longer support SHA-1-based certificates. While some legacy systems still use SHA-1, it's universally recommended to migrate away from it.

---

#### SHA-2 Family

The **SHA-2 family** was designed as a successor to SHA-1, addressing its weaknesses while preserving the general design principles. SHA-2 isn’t a single algorithm but a family of six different hash functions:

- **SHA-224**
    
- **SHA-256**
    
- **SHA-384**
    
- **SHA-512**
    
- **SHA-512/224**
    
- **SHA-512/256**
    

The number in each name refers to the bit-length of the hash output. For instance, SHA-256 produces a 256-bit (or 64 hexadecimal characters) hash, which is four times longer than MD5.

SHA-2 functions are considered **secure and reliable**, and they have become the new standard for most cryptographic applications. SHA-256, in particular, is extremely popular and is used in:

- TLS/SSL certificates
    
- Bitcoin and other cryptocurrencies
    
- Digital signatures (e.g., in PGP)
    
- Secure file verification
    

Unlike SHA-1 and MD5, SHA-2 hasn’t suffered from any practical collision attacks. Some theoretical research has analyzed potential weaknesses, but nothing has rendered it insecure in practice. Its robust design and longer hash lengths make brute-force and collision attacks vastly more difficult.

One point to note is that SHA-2 is **not optimized for constrained environments** like smart cards or embedded devices because it requires more processing power than MD5 or SHA-1. That led to the creation of an alternative: SHA-3.

---

#### SHA-3 Family

**SHA-3**, published by NIST in 2015, is the newest addition to the Secure Hash Algorithm family, but it’s **not based on the same design** as SHA-1 or SHA-2. Instead, it uses an entirely different underlying structure called the **Keccak sponge construction**.

SHA-3 was created as a **"post-SHA-2" backup** — not because SHA-2 was broken, but because the cryptographic community wanted a hash standard that would remain secure even if fundamental flaws were someday found in SHA-2.

SHA-3 supports the same output sizes as SHA-2 (224, 256, 384, and 512 bits), but its internal workings are quite different. Where SHA-2 uses a Merkle–Damgård construction, SHA-3 uses a sponge function, which is more flexible and potentially more resistant to a wide variety of cryptanalytic attacks.

The Keccak algorithm behind SHA-3 was selected through an open competition, similar to how AES was chosen. This gave the cryptographic community a chance to examine and vet the algorithm thoroughly before it was standardized.

SHA-3 is currently **considered very secure**. However, it has not yet seen widespread adoption, primarily because SHA-2 continues to be effective and widely supported. SHA-3 is particularly useful in hardware applications, where its performance characteristics (such as low power usage) are favorable.



#### RIPEMD (RACE Integrity Primitives Evaluation Message Digest)

**RIPEMD** is a family of cryptographic hash functions developed in the mid-1990s as part of an academic project in Europe. The original RIPEMD was quickly found to be insecure, leading to the release of stronger variants like **RIPEMD-128** and **RIPEMD-160**.

 RIPEMD-160 is the most popular version, producing a 160-bit hash similar to SHA-1 in length.

 It uses two parallel lines of computation, making it structurally different from MD5 and SHA-1.


**Use cases:**

 Used in PGP and Bitcoin (alongside SHA-256).

 Offers similar security to SHA-1 but is less commonly used today due to SHA-2/3 dominance.


**Drawbacks:**

 Less optimized for performance in modern hardware.

 Lacks widespread support compared to SHA family.


---

####  Whirlpool

Whirlpool is a cryptographic hash function designed by Vincent Rijmen (co-creator of AES) and Paulo Barreto. It was standardized by ISO/IEC and produces a 512-bit hash.

 Based on a block cipher called the **Advanced Encryption Standard (AES)**.

 Uses a structure called a **Substitution–Permutation Network (SPN)**.


**Use cases:**

 Long hash output (512 bits) makes it suitable for high-security applications.

 Sometimes used in digital signature and archival systems.


**Drawbacks:**

Not as widely supported in libraries or APIs.

 Slower than SHA-2 on many platforms.


---

####  BLAKE and BLAKE2 / BLAKE3

**BLAKE** is a cryptographic hash function that was one of the finalists in the SHA-3 competition. Though it didn’t win (Keccak did), it gave rise to successors:

- **BLAKE2**: A fast, secure alternative to MD5, SHA-1, and SHA-2.

- **BLAKE3**: Released in 2020, it's even faster and more modern, designed for high performance and parallelism.

 Based on ChaCha, a secure stream cipher.

 Uses a tree structure in BLAKE3, making it well-suited to multi-core processors.


**Use cases:**

 BLAKE2 is widely used in applications like IPFS, ZeroTier, and some blockchain systems.

 BLAKE3 is great for hashing large data efficiently (e.g., backups, file verification).

**Drawbacks:**

 BLAKE3 is relatively new, so adoption is still growing.

 Some conservative systems prefer NIST-endorsed algorithms like SHA-2/SHA-3.


---

### Tiger

Tiger is a fast hash function designed for use on 64-bit platforms. It produces a 192-bit hash and is known for its speed.

 Designed with 64-bit operations in mind, making it very efficient on 64-bit CPUs.

 Uses a Feistel structure and S-boxes like in block ciphers.


**Use cases:**

 File integrity verification.

 Backup systems (used in older tools like TTH in file-sharing apps).


 **Drawbacks:**

 Not widely used anymore.

 Has not seen the same level of scrutiny as SHA and BLAKE families.



---

#### Bcrypt

Based on the Blowfish cipher.

 Introduces a "cost factor" to control how slow it is.

Automatically handles salting internally.


**Strength:** Proven and widely used (e.g., in Linux systems and web apps).  

**Weakness:** Not well-suited for environments where you can use GPU acceleration to crack hashes.

---

####  Scrypt

 Builds on bcrypt but adds **memory-hardness**, which makes it costly for attackers to parallelize attacks using GPUs or ASICs.


**Strength:** More resistant to large-scale attacks.  

**Weakness:** Requires more memory and configuration tuning.

---

####  Argon2

The most modern and flexible password hashing algorithm.

Comes in three versions:

 **Argon2d** – Resistant to GPU cracking.

**Argon2i** – Resistant to side-channel attacks.

 **Argon2id** – Hybrid of both.


**Strength:** Current recommended standard for password hashing.  

**Weakness:** More complex to implement correctly without using a library.

---


### Applications of Cryptographic Algorithms

#### 1. Digital Signatures

A digital signature is a cryptographic technique used to verify the authenticity and integrity of digital data or messages. It ensures that the information has not been tampered with and provides assurance about the identity of the sender. Digital signatures are widely used in securing emails, software distribution, financial transactions, and other forms of communication.

 **How Digital Signatures Work**

Digital signatures rely on public key cryptography (asymmetric encryption). The process involves two keys: a **private key** and a **public key**.

1. **Creating a Digital Signature**:
   - The sender uses their private key to generate the digital signature.
   - A hash function is applied to the message or document to produce a fixed-length hash value (a unique fingerprint of the data).
   - This hash value is then encrypted using the sender's private key, creating the digital signature.

2. **Verifying a Digital Signature**:
   - The receiver uses the sender's public key to decrypt the digital signature, retrieving the original hash value.
   - The receiver independently computes the hash value of the received message or document.
   - If the decrypted hash value matches the computed hash value, the signature is valid, confirming the integrity of the message and the sender's identity.


### Creating Ditital Signatures Practical

We will use OpenSSL to generate digital signatures.

To verify if **GPG** (GNU Privacy Guard) is installed:

```bash
gpg --version
```

To verify if OpenSSL is installed:

```bash
openssl version
```

If not installed, install them using:

```bash
sudo apt update && sudo apt install gnupg openssl
```


**Step 1: Create a data file**

```bash
echo 'data to sign' > my_data.txt

openssl dgst -sha256 < my_data.txt > hash
```


---
#### Using OpenSSL

**1.Create private/public key pair**

```bash
openssl genrsa -out private.pem 1024
```

**2. Extracting Public key.**

```bash
openssl rsa -in private.pem -out public.pem -outform PEM -pubout
```


**3. Sign the hash using Private key to a file called example.sha256**

```bash
openssl dgst -sha256 -sign private.pem -out signature.bin my_data.txt
```

**4. Verify the file (my_data.txt)and the digital signature (signature.bin)**

```bash
openssl dgst -sha256 -verify public.pem -signature signature.bin my_data.txt
```


---
#### Using GPG

1. Run the following command:
```c
gpg --full-generate-key
```

Follow the prompts to select:

- Key type (RSA and RSA is recommended).
- Key size (2048 or 4096 bits for better security).
- Expiration time.
- Name, email, and a passphrase to protect your private key.

2. Once generated, list your keys:

```c
gpg --list-keys
```

3. Sign a file:

```c
gpg --sign my_data.txt
```


This creates a file named `my_data.txt.gpg`

4. Share Your Public Key

Distribute your public key to those who need to verify your signature. With GPG, you can export your public key:

```c
gpg --export --armor "Your Name or Email" > public_key.asc
```

Verify the signature:

```c
gpg --verify file
```

For a detached signature:

```c
gpg --detach-sign my_data.txt
```

This creates a `my_data.txt.sig`

---

 **Benefits of Digital Signatures**

- **Authentication**: Confirms the identity of the sender.
- **Integrity**: Ensures the message has not been altered during transit.
- **Non-Repudiation**: Prevents the sender from denying they sent the message, as only their private key could have created the signature.

 **Applications of Digital Signatures**

- **Email Security**: Verifying sender identity and ensuring email content integrity.
- **Document Signing**: Legally binding electronic agreements and contracts.
- **Software Distribution**: Ensuring that software updates and packages come from a trusted source.
- **Blockchain and Cryptocurrencies**: Securing transactions and validating ownership.

---

#### 2. Digital Certificates

A digital certificate is an electronic document used to prove the ownership of a public key. It acts as a digital passport, linking the public key to the identity of an individual, organization, or entity. Digital certificates are issued by trusted third parties known as **Certificate Authorities (CAs)**.

 **Purpose of Digital Certificates**
 
Digital certificates provide assurance that:

- The public key belongs to the claimed entity.
- The entity has been verified by a trusted authority.
- Communication using the public key can be trusted.

**Structure of a Digital Certificate**

A digital certificate typically contains:

- **Certificate Holder Information**: Name, email, or organization details.
- **Public Key**: The public key of the entity.
- **Certificate Authority Information**: Name and details of the issuing CA.
- **Validity Period**: Start and expiration dates of the certificate.
- **Serial Number**: A unique identifier for the certificate.
- **Digital Signature**: The CA's signature, ensuring the certificate's authenticity.

 **How Digital Certificates Work**

1. **Issuance**:
   - The entity requesting a certificate generates a public-private key pair.
   - The public key, along with identity details, is submitted to a CA for verification.
   - The CA verifies the entity's identity and issues a digital certificate.

2. **Verification**:
   - When a digital certificate is presented, the recipient verifies it using the CA's public key.
   - If valid, the certificate confirms the identity of the holder and the trustworthiness of the public key.

---
### Creating Digital Certificates Practical 


##### 1. Create a Private Key

Generate a private key with a 2048-bit RSA algorithm:

```bash
openssl genrsa -out private.key 2048
```

This file, `private.key`, will be used to sign your certificate.

---

##### 2. Create a Certificate Signing Request (CSR)

Generate a CSR to include your information:

```bash
openssl req -new -key private.key -out request.csr
```

You will be prompted to provide the following details:

- **Country Name (2-letter code)**: e.g., `US`
- **State or Province Name**: e.g., `California`
- **Locality Name (City)**: e.g., `San Francisco`
- **Organization Name**: e.g., `MyCompany`
- **Organizational Unit Name**: e.g., `IT Department`
- **Common Name**: e.g., `mydomain.com` or your name.
- **Email Address**: e.g., `admin@mydomain.com`

---

##### 3. Create a Self-Signed Certificate

Use the private key and CSR to create a self-signed certificate:

```bash
openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt
```

- `-days 365`: Validity period of 1 year.
- `certificate.crt`: The output certificate file.

---

##### 4. Verify the Certificate

Check the contents of the certificate:

```bash
openssl x509 -in certificate.crt -text -noout
```

---

##### 5. Use Your Certificate

You can now use `certificate.crt` for various purposes:

- To secure a website (HTTPS).
- To sign documents.
- For local testing purposes.

---

 **Types of Digital Certificates**

- **SSL/TLS Certificates**: Secures websites by encrypting data between the user and the server.
- **Code Signing Certificates**: Ensures the authenticity of software or applications.
- **Email Certificates**: Secures email communication by enabling encryption and digital signatures.
- **Client Certificates**: Verifies the identity of an individual in secure communications.
- **Root Certificates**: Used by CAs to sign and issue other certificates.

 **Benefits of Digital Certificates**

- **Authentication**: Ensures the identity of parties involved in a communication.
- **Encryption**: Protects sensitive data by enabling secure encryption.
- **Integrity**: Verifies that transmitted data has not been altered.
- **Trust**: Builds trust in digital communication by involving trusted CAs.

 **Example of Digital Certificate Use**

In a secure website connection (HTTPS):

1. A user visits a secure website.
2. The website presents its SSL/TLS certificate.
3. The user's browser verifies the certificate with the issuing CA.
4. If valid, an encrypted connection is established between the user and the website.

---

## Steganography

Steganography is the practice of concealing information within another medium, such as an image, audio file, video, or text, in a way that hides the existence of the hidden data. 

Unlike cryptography, which makes data unreadable to unauthorized users, steganography aims to keep the very presence of the data undetectable.

### Types of Steganography

1. **Text Steganography**

 Text Steganography is defined as a type of steganography which involves caching dispatches or secret information within a textbook document or other textual data.
 
2. **Image Steganography**

Image Steganography is defined as a type of steganography which involves caching dispatches or secret information within digital images. 

3. **Audio Steganography**

Audio Steganography is defined as a type of steganography which involves caching dispatches or secret information within audio lines.

4. **Video Steganography**

Video Steganography is defined as a type of steganography which involves caching dispatches or secret information within digital videotape lines.

5. **Network Steganography**

Video Steganography is defined as a type of steganography which involves caching dispatches or secret information within data packets.

---

## Steghide Practical



##### 1. Embedding Data in a Carrier File

```c
steghide embed -cf [carrier_file] -ef [secret_file] -p [password]
```

- **`-cf`**: Specifies the carrier file.
- **`-ef`**: Specifies the file to hide.
- **`-p`**: Sets a password for retrieving the hidden data.


```c
steghide embed -cf image.jpg -ef secret.txt -p mypassword
```

This embeds `secret.txt` into `image.jpg` using the password `mypassword`.

---

##### 2. Extracting Data from a Carrier File

```c
steghide extract -sf [carrier_file] -p [password]
```

- **`-sf`**: Specifies the carrier file containing hidden data.
- **`-p`**: Provides the password to access the hidden data.

```c
steghide extract -sf image.jpg -p mypassword
```

This extracts the hidden `secret.txt` from `image.jpg` using the password `mypassword`.

Verify if Image has Embeded Files

``` c
steghide info image.jpg
```

---
##### 1. Hide Data Inside an Audio File

To embed a text file (secret.txt) inside an audio file (audio.mp3), use:

```c
steghide embed -cf audio.wav -ef secret.txt
```

- `cf`: Cover file (the audio file).
- `ef`: Embedded file (the file you want to hide).

You will be prompted to set a passphrase. Choose a strong passphrase for security.

```c
ffmpeg -i audio.mp3 -acodec pcm16le -ar 44100 audio.wav
```

---
##### 2. Verify the Hidden Data

To check if data has been embedded inside the audio file:

```c
steghide info audio.wav
```

If data is hidden, it will confirm the presence of embedded information.

---

##### 3. Extract the Hidden Data

To retrieve the hidden file:

```c
steghide extract -sf audio.wav
```

- `sf`: Stego file (audio file containing the hidden data).

Enter the correct passphrase, and the hidden file will be extracted.

---

### Method 2: Using FFmpeg with Silent Data Embedding

If Steghide does not work well with MP3 files, you can try using **ffmpeg** with a steganography approach.

##### Step 1: Convert Text to Audio

Convert a text file into an audio file (WAV format):

```c
cat secret.txt | text2wave -o secret.wav
```

##### Step 2: Merge the Secret Audio with the Cover Audio

Merge it with an existing audio file:

```c
ffmpeg -i audio.mp3 -i secret.wav -filter_complex "[0:a][1:a]amix=inputs=2:duration=longest" output.mp3
```

##### Step 3: Extract the Hidden Audio

You can use **Audacity** to extract the hidden audio by separating the sound layers.

- Launch Audacity
- Click **File > Open** and select `output.mp3`.

```c
ffmpeg -i output.mp3 -af areverse reversed.mp3
```

Then, open `reversed.mp3` in Audacity.


---
### Applications of Steganography

 **Data Confidentiality**:
- Transmits sensitive data covertly, hiding the presence of the communication.

 **Watermarking**:
- Embeds ownership or copyright information into media files (images, videos, etc.).

 **Digital Rights Management (DRM)**:
- Protects intellectual property by embedding information about usage rights.

 **Covert Communications**:
- Used in scenarios where secrecy is crucial, such as intelligence operations.

 **Authentication**:
- Embeds metadata or hidden tags to verify the authenticity of documents or media.

---

### Advantages of Steganography

- Maintains secrecy by hiding the presence of data.
- Difficult to detect without specialized tools.
- Can be combined with cryptography for enhanced security.

---

### Limitations of Steganography

- **Vulnerability to Detection**: Steganalysis techniques can identify hidden data by analyzing patterns.
- **Limited Capacity**: The amount of hidden data depends on the medium.
- **Degradation Risk**: Alterations to the medium (e.g., image compression) may destroy the hidden data.

---

### Steganography vs. Cryptography

|**Aspect**|**Steganography**|**Cryptography**|
|---|---|---|
|**Goal**|Hides the existence of data.|Scrambles data to make it unreadable.|
|**Detection**|Difficult to detect if done correctly.|Presence of encrypted data is obvious.|
|**Combination**|Often used together for enhanced security.|Cryptographic data can be embedded using steganography.|

---

### Steganography Tools

- OpenStego
- Steghide
- OutGuess
- Hide n shoot
- QuickStego
- Disguise

### Hardware-Based Mechanisms for Protecting Data

Hardware-based mechanisms are designed to provide robust protection for sensitive data by using physical devices or components that are resistant to attacks or unauthorized access. These mechanisms are often more secure than software-based solutions because they are less vulnerable to certain types of attacks, such as malware or remote exploitation. 

 **Full Disk Encryption (FDE) Using Hardware**

 FDE is implemented at the hardware level to encrypt the entire storage device (e.g., hard drive or SSD) so that data is automatically encrypted before being written to disk and decrypted when accessed.
 
**Functions**:

- Transparent encryption and decryption without requiring user intervention.
- Hardware-based encryption offloading to reduce system resource usage.

**Applications**:

- Protecting data on laptops and desktop computers from unauthorized access if the device is lost or stolen.
- Used in enterprise environments to secure endpoints.

**USB Hardware Encryption Drives**

These are physical USB drives equipped with hardware encryption capabilities. They automatically encrypt data stored on the drive and require authentication to access it.

**Functions**:

- On-the-fly encryption and decryption of data.
- Protects against unauthorized access in case of theft or loss.

**Applications**:

- Portable data storage for sensitive information.
- Secure file transfer between devices

---


### Software-Based Mechanisms for Protecting Data

Software-based mechanisms are designed to protect sensitive data through the use of software applications or configurations. 

While these mechanisms are more flexible and easier to deploy than hardware solutions, they may be more vulnerable to software-based attacks such as malware, ransomware, or unauthorized access.

#### Encryption Software

Encryption software is used to encode data so that only authorized users or systems can decrypt and access it.

**Types of Encryption:**

- Full Disk Encryption (FDE): Encrypts the entire disk to protect all stored data (e.g., BitLocker, FileVault).

- File or Folder Encryption: Encrypts individual files or folders (e.g., AxCrypt, VeraCrypt).

- End-to-End Encryption: Ensures that only the sender and receiver can decrypt messages (e.g., Signal, WhatsApp).

Applications:

- Protects sensitive files, emails, or data on portable devices like laptops.
- Ensures confidentiality in transit, such as during email or messaging.

#### Password Management Software

Password management software stores and manages passwords in an encrypted vault, reducing the risk of password-related security breaches.

**Functions:**

- Generates and stores complex passwords.
- Encrypts password databases for protection.
- Facilitates secure password sharing and password recovery.

**Applications:**

- Helps individuals and organizations manage multiple accounts and passwords securely.
- Prevents password theft or leaks by securely storing login information.


#### Secure File Transfer Software

Software designed to encrypt files and ensure their secure transfer over untrusted networks (e.g., the internet).

**Functions:**

- Encrypts files during transmission using protocols like FTPS or SFTP.
- Ensures the integrity of the data being transferred.
- Provides secure authentication and authorization for file access.

**Applications:**

- Protects sensitive data during file sharing or transfer between systems or users.
- Used in industries like finance, healthcare, and legal sectors for secure document exchange.

## Data Masking

Data masking is the process of obfuscating or transforming sensitive data to protect it while maintaining its usability for testing, development, or analysis purposes. 

The goal is to prevent unauthorized access to sensitive information by replacing the original data with a masked version that is functionally similar but does not expose actual confidential details. 

This technique is commonly used in environments where sensitive data needs to be used for non-production purposes, such as in development or testing.

#### Types of Data Masking Techniques

1. **Static Data Masking (SDM)**  
   A process that creates a masked copy of the original dataset, with sensitive data obfuscated for non-production environments.

2. **Dynamic Data Masking (DDM)**  
   Masks data in real-time, allowing sensitive information to be protected based on user roles or permissions without altering the original dataset.

3. **Deterministic Data Masking**  
   Replaces the original data with fixed, consistent masked values that always map to the same masked value for each occurrence.

4. **Non-Deterministic Data Masking**  
   Replaces data with random values, ensuring that no predictable relationships exist between the original and masked data.

5. **Substitution**  
   Replaces sensitive data with realistic but fictitious values, maintaining the format but obfuscating the actual information.

6. **Shuffling**  
   Randomly rearranges data within a field or column, obscuring relationships between values.

7. **Date Shifting**  
   Replaces dates with shifted values, maintaining the date format while altering the actual date to ensure privacy.

8. **Nulling Out**  
   Replaces sensitive data with null or empty values, effectively removing the data while retaining the structure of the field.

 **Advantages of Data Masking**

- **Data Protection**: Safeguards sensitive information during testing, development, and other non-production activities.
- **Compliance**: Helps ensure compliance with data privacy regulations (e.g., GDPR, HIPAA, PCI-DSS).
- **Preserves Data Integrity**: Allows data to be used effectively in development and testing environments without exposing sensitive content.
- **Reduces Risk**: Limits the risk of data breaches by preventing the exposure of real sensitive data.


**Limitations of Data Masking**

- **Complexity**: Implementing data masking can be complex, particularly in large, dynamic systems.
- **Performance Impact**: Some techniques (e.g., real-time masking) may have performance overheads.
- **Non-Deterministic Masking**: In some cases, non-deterministic techniques might make it difficult to preserve the relationships between masked data.
- **Not a Complete Solution**: While masking helps protect data, it should be used in conjunction with other security mechanisms (e.g., encryption, access controls).

#### **Data Erasure**

**Data erasure** is the process of permanently and irreversibly removing data from a storage device, ensuring that it cannot be recovered or accessed. 

This is different from simply deleting files or formatting a disk, as those methods often leave residual data that can be recovered using special tools.

Data erasure ensures that sensitive information is completely wiped from the storage medium to prevent unauthorized access or data recovery.

---

**Key Concepts of Data Erasure**

**1. Complete Data Destruction**
Data is wiped such that it cannot be recovered, ensuring the privacy of sensitive information.

**2. Irreversible Process**
Once data is erased, there is no way to recover or reconstruct it, even with advanced forensic tools.

**3. Compliance**
Data erasure is used to comply with data privacy laws and regulations (e.g., GDPR, HIPAA, PCI-DSS) that require data to be permanently erased when no longer needed.

**4. Methods**
Data erasure can be performed using various software tools or hardware methods, such as physical destruction of storage devices.

---

 **Advantages of Data Erasure**

- **Data Security**: Protects sensitive data from unauthorized access after disposal or decommissioning of storage devices.
- **Compliance**: Helps organizations comply with legal and regulatory data retention and destruction requirements.
- **Environmental Responsibility**: When combined with physical destruction, it ensures that devices are safely disposed of, protecting both data privacy and the environment.

---

**Limitations of Data Erasure**

- **Residual Data**: In some cases, particularly with older technologies or faulty equipment, residual data may still be recoverable.
- **Performance Impact**: Software-based erasure can be time-consuming, especially with large volumes of data.
- **Cost**: Physical destruction or degaussing of storage devices may incur additional costs, especially for large-scale data erasure.

### Biometric Security

**Biometric security** refers to the use of unique physiological or behavioral characteristics to verify the identity of individuals. These traits are considered difficult to replicate or steal, making them a highly effective form of authentication for securing access to systems, devices, and physical locations.

#### Types of Biometric Security

**Fingerprint Recognition**

Uses the unique patterns of ridges and valleys on a person’s fingertip to verify identity. It's one of the most commonly used biometric methods, found in smartphones and other security systems.

**Facial Recognition**

Analyzes the unique features of a person’s face, such as the distance between eyes, nose shape, and overall face structure. This method is used in various security systems and surveillance tools.

**Iris Recognition**

Scans the unique patterns in the iris of the eye to verify identity. The iris is highly stable over time, making this method highly accurate and secure.

**Retina Scanning**

Captures the unique pattern of blood vessels in the back of the eye (retina). Retina scans are highly accurate but typically require specialized equipment.

**Voice Recognition**

Analyzes the unique characteristics of a person's voice, including pitch, tone, and speech patterns. It is used in phone-based authentication systems and voice-activated assistants.

**Hand Geometry Recognition**

Measures and analyzes the shape and size of a person’s hand. It’s less accurate than other methods but still used in certain environments, such as access control systems.

**Signature Recognition**

Analyzes the unique patterns and dynamics of how a person writes their signature, including pressure, speed, and stroke order. This method is used for document verification and digital signatures.

**Gait Recognition**

Analyzes the way a person walks to identify them. It’s still an emerging technology, with potential applications in surveillance and security.

**Vein Recognition**

Uses infrared light to capture the unique patterns of veins in a person's hand or finger. It's a highly accurate method, but the technology is less common.

 **Advantages of Biometric Security**

- **Convenience**: Biometric systems are generally easy to use, as individuals do not need to remember passwords or carry tokens.
- **Accuracy**: Biometric traits are unique to each individual, offering a high level of authentication accuracy.
- **Security**: Since biometric data is hard to replicate or steal, it provides a robust layer of security.
- **Non-transferable**: Unlike passwords or cards, biometrics cannot be easily transferred or shared.

 **Challenges of Biometric Security**

- **Privacy Concerns**: The collection and storage of biometric data raise significant privacy issues, as it is sensitive and personal information.
- **False Positives/Negatives**: No system is perfect, and biometric systems may occasionally fail to recognize a legitimate user (false negative) or incorrectly authenticate an unauthorized user (false positive).
- **Data Storage**: Storing biometric data securely is crucial. If biometric data is compromised, it cannot be changed like a password or PIN.
- **Cost**: Implementing biometric systems can be expensive due to the specialized equipment and infrastructure required.


 **Use Cases of Biometric Security**

- **Mobile Devices**: Many smartphones use fingerprint, facial, or iris recognition for user authentication.
- **Banking and Payments**: Some financial institutions use voice recognition or fingerprint scanning for secure transactions and account access.
- **Access Control**: Biometric systems are widely used in physical security systems, such as building entry, to verify the identity of employees or authorized personnel.
- **Healthcare**: Hospitals and clinics use biometric systems to secure access to patient records and verify staff identities.
- **Surveillance**: Law enforcement and security agencies use facial recognition and other biometric systems for monitoring and identifying individuals in crowds or on surveillance footage.

---



