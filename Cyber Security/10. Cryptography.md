
Encryption is essentially important because it secures data and information from unauthorized access and thus maintains confidentiality.

### Key Terms 

**Ciphertext** - The result of encrypting a plaintext, encrypted data

**Cipher** - A method of encrypting or decrypting data. Modern ciphers are cryptographic, but there are many non cryptographic ciphers like Caesar.

**Plaintext** - Data before encryption, often text but not always. Could be a photograph or other file

**Encryption** - Transforming data into ciphertext, using a cipher.

**Encoding** - NOT a form of encryption, just a form of data representation like base64. 

**Key** - Some information that is needed to correctly decrypt the ciphertext and obtain the plaintext.

**Passphrase** - Separate to the key, a passphrase is similar to a password and used to protect a key.

**Asymmetric encryption** - Uses different keys to encrypt and decrypt.

**Symmetric encryption** - Uses the same key to encrypt and decrypt

**Brute force** - Attacking cryptography by trying every different password or every different key

**Algorithm** - Algorithms are the rules or instructions for the encryption process.

 **Key exchange** - Key exchange is the method used to share cryptographic keys between a sender and their recipient.

**Cryptanalysis**

Cryptanalysis is the study of analyzing information systems in order to study the hidden aspects of the systems. Cryptanalysis is used to breach cryptographic security systems and gain access to the contents of encrypted messages, even if the cryptographic key is unknown. Methodologies like Brute force, Dictionary attacks, Rainbow table attacks have all stemmed from cryptanalysis. The success of cryptanalysis depends on the time one has, the computing power available and also the storage.

### What Is Cryptography?

**Cryptography is the practice and study of techniques for securing communication and data in the presence of adversaries.**

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*uQKUmkGy8VdZTb8MnFWrcQ.png)


### Principles Of Cryptography

- **Confidentiality:** Information can only be accessed by the person for whom it is intended and no other person except him can access it.

- **Integrity:** Information cannot be modified in storage or transition between sender and intended receiver without any addition to information being detected.

- **Non-repudiation:** The creator/sender of information cannot deny his intention to send information at a later stage.

- **Authentication:** The identities of the sender and receiver are confirmed. As well destination/origin of the information is confirmed.

- **Interoperability:** Cryptography allows for secure communication between different systems and platforms.

- **Adaptability:** Cryptography continuously evolves to stay ahead of security threats and technological advancements.


## Types of Cryptography

Cryptography can be categorized into two types:

1. **Classic Cryptography:** It refers to the historical methods and techniques of [encryption](http://encryption/) used before the advent of computers and modern cryptographic algorithms. It can be divided into subtypes, including:

- **Caesar Cipher:** A substitution cipher in which each letter is shifted to a fixed number of positions.
  
- **Vigenere Cipher:** A polyalphabetic substitution cipher that uses multiple Caesar ciphers based on a keyword.
  
- **Playfair Cipher:** A substitution cipher that uses a 5x5 matrix of letters to encrypt pairs of letters.
  
- **Rail Fence Cipher:** A transposition cipher that writes the message in a zigzag pattern.
  
- **Transposition Cipher:** Rearranges characters to encrypt plaintext messages.
  
- **Atbash Cipher:** Substitutes each letter with its reverse alphabet counterpart.

**2. Modern Cryptography:** It refers to the cryptographic algorithms and techniques developed since the mid-20th century with the advancements in computing technology. It can be divided into subtypes, including:

- **Symmetric Key Cryptography:** Utilizes a single secret key for both encryption and decryption, such as AES.
  
- **Asymmetric Key Cryptography:** Utilizes key pairs (public and private keys) for encryption and decryption, like RSA.
  
- **Hash Functions:** Generate fixed-size hash values to verify integrity and create digital signatures.
  
- **Digital Signatures**: Provide authentication and integrity using asymmetric encryption and hash functions.
  
- **Key Exchange Algorithms:** Enable secure key exchange over insecure channels, such as Diffie-Hellman and ECDH.

---

#### What is Encoding?

Encoding data is a process involving changing data into a new format using a scheme. Encoding is a reversible process and data can be encoded to a new format and decoded to its original format. Encoding typically involves a publicly available scheme that is easily reversed. Encoding data is typically used to ensure the integrity and usability of data and is commonly used when data cannot be transferred in its current format between systems or applications. Encoding is **not** used to protect or secure data because it is easy to reverse.

**An example of encoding is: Base64**

Take a scenario where a user wants to upload a resume to a job application website and the web server stores the file as a .docx file. The user's resume may contain confidential information such as their home address, date of birth or social security number. To protect this data, the user could encode their resume to Base64 prior to uploading it to the website. Once the resume has been uploaded, the web server would then decode it back to its .docx format for storage.

#### What is Hashing?

Hashing is a one-way process where data is transformed into a fixed length alphanumeric string. This string is known as a hash or message digest. A hash cannot be reversed back to the original data because it is a one-way operation. Hashing is commonly used to verify the integrity of data, commonly referred to as a checksum. If two pieces of identical data are hashed using the same hash function, the resulting hash will be identical. If the two pieces of data are different, the resulting hashes will be different and unique.

In addition to verifying the integrity of data, hashing is the recommended data transformation technique in authentication processes for computer systems and applications. It is recommended to never store passwords and instead store only the hash of the “salted password”. A salt is a random string appended to a password that only the authentication process system knows; this guarantees that if two users have the same password the stored hashes are different.

When a user inputs a password to a web application, the password is sent to the web server. The web server then appends the salt to the password and performs a hash function on the password and a salt and compares this output hash with the hash stored in the database for the user. If the hashes match for that user, the user is granted access. Hashing ensures in the event of a breach, or malicious insider the original passwords can never be retrieved. Salting ensures that, if a breach does occur, an attacker cannot determine which users have the same passwords.

**An example of a hash function is: SHA512**

As an example, say Alice wants to send Bob a file and verify that Bob has the exact same file and that no changes occurred in the transferring process. Alice will email Bob the file along with a hash of the file. After Bob downloads the file, he can verify the file is identical by performing a hash function on the file and verify the resulting hash is the same as Alice provided.

#### What is Encryption?

Encryption is the process of securely encoding data in such a way that only authorized users with a key or password can decrypt the data to reveal the original. Encryption is used when data needs to be protected so those without the decryption keys cannot access the original data. When data is sent to a website over HTTPS it is encrypted using the public key type. While encryption does involve encoding data, the two are not interchangeable terms, encryption is always used when referring to data that has been securely encoded. Encoding data is used only when talking about data that is not securely encoded.

**There are two basic types of encryption: symmetric key and public key.**

In a symmetric key, the same key is used to encrypt and decrypt data, like a password. In public key encryption, one key is used to encrypt data and a different key is used to decrypt the data.

**An example of encryption is: AES 256**

AES is the Advanced Encryption Standard and is a symmetric key encryption. AES uses a 256-bit key which means there are 2^256, or 1.158x10^77, possible keys that can be used.

**Summary**

- **Encoding:** Reversible transformation of data format, used to preserve the usability of data.

- **Hashing:** A one-way summary of data that cannot be reversed and is used to validate the integrity of data.

- **Encryption:** Secure encoding of data used to protect the confidentiality of data.


---
## Cryptography Techniques


#### Encryption Algorithms

Encryption is a process that converts readable data (plaintext) into an unreadable format (ciphertext), making it secure from unauthorized access. 

**Key Concepts:**

**Plaintext**: The original, readable data.

**Ciphertext**: The encrypted, unreadable data.

**Key**: A secret code used to encrypt and decrypt data. 

Cryptography is broadly classified into two categories: ***Symmetric key Cryptography*** and ***Asymmetric key Cryptography*** (popularly known as public key cryptography).

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*-ZubnDvcxP7cy8JUgUX4Eg.png)


### How various Cryptographic Algorithms Works?

Let’s start with the Symmetric key encryption

#### Symmetric Key Cryptography

> An **encryption** system in which the sender and receiver of a message share a single, common **key** that is used to encrypt and decrypt the message. The most popular **symmetric** – **key** system is the Data **Encryption** Standard (DES).

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*1zgMNGVF1fRjwJxRKI5Wvg.png)

#### Transposition Ciphers

> In Cryptography, a transposition cipher is a method of encryption by which the positions held by units of plaintext (which are commonly characters or groups of characters) are shifted according to a regular system, so that the ciphertext constitutes a permutation of the plaintext.

That is, the order of the units is changed (the plaintext is reordered). Mathematically, a bijective function is used on the characters’ positions to encrypt and an inverse function to decrypt.

***Example:***

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*PcZi89bNwU2oird8UQ90dw.png)

#### Substitution Cipher

> Method of encryption by which units of plaintext are replaced with ciphertext, according to a fixed system; the “units” may be single letters (the most common), pairs of letters, triplets of letters, mixtures of the above, and so forth.

***Example:***

Consider this example shown on the slide: Using the system just discussed, the keyword “zebras” gives us the following alphabets:

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*Pt0ZgOYMA1pXwtUVTrtgdQ.png)

#### Stream Cipher

> Symmetric or secret-key encryption algorithm that encrypts a single bit at a time. With a Stream Cipher, the same plaintext bit or byte will encrypt to a different bit or byte every time it is encrypted.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*nsXiNh0zM7LwoOQe0e8bUA.png)

#### Block Cipher

> An encryption method that applies a deterministic algorithm along with a symmetric key to encrypt a block of text, rather than encrypting one bit at a time as in stream ciphers

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*5r-ePZOfkohw_c3reTYPgw.png)

***Example:*** A common block cipher, AES, encrypts 128-bit blocks with a key of predetermined length: 128, 192, or 256 bits. Block ciphers are pseudorandom permutation (PRP) families that operate on the fixed size block of bits. PRPs are functions that cannot be differentiated from completely random permutations and thus, are considered reliable until proven unreliable.


### Asymmetric Key Encryption (or Public Key Cryptography)

The encryption process where different keys are used for encrypting and decrypting the information. Keys are different but are mathematically related, such that retrieving the plain text by decrypting ciphertext is feasible.

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*GjT-QXp9iAaXdj3HrzOX3A.png)

RSA is the most widely used form of public key encryption,

### RSA Algorithm

- RSA stands for *Rivest, Shamir, and Adelman*, inventors of this technique
- Both public and private key are interchangeable
- Variable Key Size (512, 1024, or 2048 bits)

*Here’s how keys are generated in RSA algorithm*

![](https://miro.medium.com/v2/resize:fit:640/format:webp/1*Zc1M84hbfFCE1fp8iNA8-A.png)

Alright, this was it for “What is Cryptography” article. To safeguard your information and data shared over the internet it is important to use strong encryption algorithms, to avoid any catastrophic situations.

---

## Practical 

#### 1. Generate a Symmetric Key

**Command:**

```bash
openssl rand -out symmetric.key 32
```

**Options:**

- rand: Generates random bytes.
  
- -out symmetric.key: Saves output to symmetric.key.
  
- 32: Number of bytes to generate (32 bytes = 256 bits for AES-256).

---

#### 2. Encrypt Files Using Symmetric Encryption

**Command:**

```bash
openssl enc -aes-256 -salt -in plaintext.txt -out encrypted-text.txt -pass file:symmetric.key
```

**Options:**

- enc: Encrypt utility.
  
- -aes-256-cbc: Algorithm used (AES-256).
  
- -salt: Adds salt to encryption.
  
- -in plaintext.txt: Input file.
  
- -out encrypted.sym: Output file.
  
- -pass file: symmetric.key: Use key from file.

---

#### 3. Decrypt Files Using Symmetric Encryption

**Command:**

```bash
openssl enc -d -aes-256 -in encrypted-text.txt -out decrypted.txt -pass file:symmetric.key
```

**Options:**

- -d: Decrypt mode.
  
- Other options same as encryption.


---

**View the Symmetric Key**

```bash
xxd symmetric.key
```

Show Key in Hexadecimal format.


---

#### Generate an Asymmetric RSA Key Pair


#### Generate Private Key:

**Command:**

```bash
openssl genrsa -out private_key.pem 2048
```

**Options:**

- -genras: Command to generate a private key using RSA algorithm.
  
- -out private-key.pem: Saves private key.
  
- 2048: Sets RSA key size to 2048 bits.

---

#### 2. Extract Public Key:

**Command:**

```bash
openssl rsa -in private-key.pem -out public-key.pem -outform PEM -pubout
```

Options:

- rsa: RSA utility.
  
- -in private-key.pem: Input private key.
  
- -outform PEM : Save key in PEM format
  
- -pubout: Output the public key.
  
- -out public-key.pem: Save the public key.

---



#### 3. Encrypt Files using Asymmetric Keys

Command:

```bash
openssl rsautl -encrypt -inkey public-key.pem -pubin -in plaintext.txt -out encrypted.asym
```

Options:

- rsautl: RSA encryption/decryption utility.
  
- -encrypt: Mode for encryption.
  
- -inkey public.key: Use public key.
  
- -pubin: Treat the key as a public key.
  
- -in plaintext.txt: Input file.
  
- -out encrypted.asym: Output file.

---

#### 4. Decrypting Files using Asymmetric Keys


**Command:**

```bash
openssl rsautl -decrypt -inkey private-key.pem -in encrypted-text.txt -out decrypted-text.txt
```

**Options:**

- rsautl: RSA encryption/decryption utility.

- -decrypt: Decryption mode.
  
- -inkey private.key: Use private key.
  
- -in encrypted.asym: Encrypted file.
  
- -out decrypted.txt: Output file.


----
## Hash Functions

A hash function is a mathematical algorithm that takes an input (or 'message') and returns a fixed-size string of bytes. The output is typically a sequence of seemingly random characters called a hash value, message digest, or simply a digest.

Hash functions are different from encryption. There is no key, and it’s meant to be impossible (or computationally impractical) to go from the output back to the input.

A hash function takes some input data of any size and creates a summary or **digest** of that data. The output has a fixed size. It’s hard to predict the output for any input and vice versa. Good hashing algorithms will be relatively fast to compute and prohibitively slow to reverse, i.e., go from the output and determine the input. Any slight change in the input data, even a single bit, should cause a significant change in the output.


#### Purpose of Hashing in Cryptography

Hash functions serve several purposes in cryptographic systems:

- Data Integrity: To ensure that data has not been altered. If the hash of the original data matches the hash of the received data, the data is presumed intact.

- Password Storage: Systems store the hash of passwords, not the passwords themselves. When a user logs in, the system hashes the entered password and compares it with the stored hash.

- Digital Signatures: Involves hashing a message before signing it with a private key to ensure both authenticity and integrity.

- Message Authentication Codes (MACs): Hash functions form part of HMACs, which are used to authenticate messages.


#### Properties of a Good Cryptographic Hash Function

To be cryptographically secure, a hash function must satisfy these core properties:

**a.) Deterministic**

Given the same input, it always produces the same hash output.

**b.) Fast Computation**

It should be able to compute the hash value quickly.

**c.) Pre-image Resistance**

Given a hash output, it should be computationally infeasible to find an input that hashes to that output. This protects against recovering the original data.

**d.) Second Pre-image Resistance**

Given input A and its hash, it should be infeasible to find a different input B (B ≠ A) such that hash(B) = hash(A).

**e.) Collision Resistance**

It should be hard to find any two different inputs that produce the same hash output. A collision breaks the integrity of the hash function.

**f.) Avalanche Effect**

A small change in the input should result in a significantly different hash.


### Rainbow Table Attack

A Rainbow Table Attack is a cryptographic attack method that uses precomputed tables of hash values to quickly reverse-engineer plaintext passwords from their hashed counterparts. 

A Rainbow Table is essentially a giant lookup table containing pairs of plaintext passwords and their corresponding hash values. When a hacker obtains a hashed password, they can search for this hash in the Rainbow Table. If a match is found, the hacker can easily determine the original password.

#### Protecting Against Rainbow Tables

To protect against rainbow tables, we add a salt to the passwords. The salt is a randomly generated value stored in the database and should be unique to each user. In theory, you could use the same salt for all users, but duplicate passwords would still have the same hash and a rainbow table could still be created for passwords with that salt.


**A salt is a random string of characters added to a password before it's hashed.**

The salt is added to either the start or the end of the password before it’s hashed, and this means that every user will have a different password hash even if they have the same password. Hash functions like Bcrypt and Scrypt handle this automatically. Salts don’t need to be kept private.

#### Example of Securely Storing Passwords

You can find many good guides online that promote best security practices when storing passwords. Please check if there are any standards you need to follow when storing passwords before adopting one. Consider this example following good security practices when storing user passwords:

1. We select a secure hashing function, such as Argon2, Scrypt, Bcrypt, or PBKDF2.
   
2. We add a unique salt to the password, such as `Y4UV*^(=go_!`
   
3. Concatenate the password with the unique salt. For example, if the password is `AL4RMc10k`, the result string would be `AL4RMc10kY4UV*^(=go_!`
   
4. Calculate the hash value of the combined password and salt. In this example, using the chosen algorithm, you need to calculate the hash value of `AL4RMc10kY4UV*^(=go_!`.
   
5. Store the hash value and the unique salt used (`Y4UV*^(=go_!`).

#### Using Encryption to Store Passwords

Considering the problem of saving passwords for authentication, why don’t we encrypt passwords instead of all these cumbersome steps? The reason is that even if we select a secure hashing algorithm to encrypt the passwords before storing them, we still need to store the used key. Consequently, if someone gets the key, they can easily decrypt all the passwords.

---

## Popular Hash Algorithms


#### MD5 (Message Digest 5)

**MD5**, developed by Ronald Rivest in 1991, was one of the first hash algorithms to gain widespread adoption. It was designed to produce a 128-bit hash value, typically represented as a 32-character hexadecimal number. Its primary purpose was to verify data integrity, and it was commonly used in software downloads to ensure that files weren’t corrupted or tampered with.

For example, you might download a software installer and see an MD5 checksum published alongside it. You’d then run a tool to compute the MD5 hash of your downloaded file and compare it to the given checksum. If they matched, you could assume the file hadn’t been altered.

However, over time, researchers discovered serious vulnerabilities in MD5. In 2004, the first practical collision was demonstrated. A **collision** occurs when two different inputs produce the same hash output. This is extremely dangerous in cryptographic contexts. By 2008, techniques had advanced to the point where attackers could generate collisions quickly and inexpensively, undermining the security of any system using MD5 for things like digital signatures or certificates.

As a result, MD5 is now considered **cryptographically broken** and is deprecated for all security-sensitive applications. It is still used in non-security contexts (e.g., basic checksumming), but it is no longer trusted in any system requiring true data security.

---

#### SHA-1 (Secure Hash Algorithm 1)

SHA-1 was developed by the U.S. National Security Agency (NSA) and published by the National Institute of Standards and Technology (NIST) in 1995. Like MD5, it was designed for integrity verification but produces a slightly longer hash — 160 bits instead of MD5’s 128.

For years, SHA-1 was the standard for cryptographic hashing in secure protocols like SSL/TLS, PGP, and Git. You could think of it as the industry’s go-to hashing tool in the early 2000s. It was widely embedded in software libraries, hardware devices, and digital certificate systems.

However, it too fell victim to advances in cryptanalysis. Around 2005, weaknesses in SHA-1’s internal structure were discovered that made theoretical collision attacks possible. In 2017, Google and CWI Amsterdam announced the **SHAttered attack**, the first practical collision for SHA-1 using real-world files (specifically, two PDF files that had the same SHA-1 hash). This was a watershed moment that proved SHA-1 was no longer secure in practice, not just in theory.

Today, SHA-1 is deprecated in all major standards and protocols. Most web browsers and certificate authorities no longer support SHA-1-based certificates. While some legacy systems still use SHA-1, it's universally recommended to migrate away from it.

---

#### SHA-2 Family

The **SHA-2 family** was designed as a successor to SHA-1, addressing its weaknesses while preserving the general design principles. SHA-2 isn’t a single algorithm but a family of six different hash functions:

- **SHA-224**
    
- **SHA-256**
    
- **SHA-384**
    
- **SHA-512**
    
- **SHA-512/224**
    
- **SHA-512/256**
    

The number in each name refers to the bit-length of the hash output. For instance, SHA-256 produces a 256-bit (or 64 hexadecimal characters) hash, which is four times longer than MD5.

SHA-2 functions are considered **secure and reliable**, and they have become the new standard for most cryptographic applications. SHA-256, in particular, is extremely popular and is used in:

- TLS/SSL certificates
    
- Bitcoin and other cryptocurrencies
    
- Digital signatures (e.g., in PGP)
    
- Secure file verification
    

Unlike SHA-1 and MD5, SHA-2 hasn’t suffered from any practical collision attacks. Some theoretical research has analyzed potential weaknesses, but nothing has rendered it insecure in practice. Its robust design and longer hash lengths make brute-force and collision attacks vastly more difficult.

One point to note is that SHA-2 is **not optimized for constrained environments** like smart cards or embedded devices because it requires more processing power than MD5 or SHA-1. That led to the creation of an alternative: SHA-3.

---

#### SHA-3 Family

**SHA-3**, published by NIST in 2015, is the newest addition to the Secure Hash Algorithm family, but it’s **not based on the same design** as SHA-1 or SHA-2. Instead, it uses an entirely different underlying structure called the **Keccak sponge construction**.

SHA-3 was created as a **"post-SHA-2" backup** — not because SHA-2 was broken, but because the cryptographic community wanted a hash standard that would remain secure even if fundamental flaws were someday found in SHA-2.

SHA-3 supports the same output sizes as SHA-2 (224, 256, 384, and 512 bits), but its internal workings are quite different. Where SHA-2 uses a Merkle–Damgård construction, SHA-3 uses a sponge function, which is more flexible and potentially more resistant to a wide variety of cryptanalytic attacks.

The Keccak algorithm behind SHA-3 was selected through an open competition, similar to how AES was chosen. This gave the cryptographic community a chance to examine and vet the algorithm thoroughly before it was standardized.

SHA-3 is currently **considered very secure**. However, it has not yet seen widespread adoption, primarily because SHA-2 continues to be effective and widely supported. SHA-3 is particularly useful in hardware applications, where its performance characteristics (such as low power usage) are favorable.



#### RIPEMD (RACE Integrity Primitives Evaluation Message Digest)

**RIPEMD** is a family of cryptographic hash functions developed in the mid-1990s as part of an academic project in Europe. The original RIPEMD was quickly found to be insecure, leading to the release of stronger variants like **RIPEMD-128** and **RIPEMD-160**.

 RIPEMD-160 is the most popular version, producing a 160-bit hash similar to SHA-1 in length.

 It uses two parallel lines of computation, making it structurally different from MD5 and SHA-1.


**Use cases:**

 Used in PGP and Bitcoin (alongside SHA-256).

 Offers similar security to SHA-1 but is less commonly used today due to SHA-2/3 dominance.


**Drawbacks:**

 Less optimized for performance in modern hardware.

 Lacks widespread support compared to SHA family.


---

####  Whirlpool

Whirlpool is a cryptographic hash function designed by Vincent Rijmen (co-creator of AES) and Paulo Barreto. It was standardized by ISO/IEC and produces a 512-bit hash.

 Based on a block cipher called the **Advanced Encryption Standard (AES)**.

 Uses a structure called a **Substitution–Permutation Network (SPN)**.


**Use cases:**

 Long hash output (512 bits) makes it suitable for high-security applications.

 Sometimes used in digital signature and archival systems.


**Drawbacks:**

Not as widely supported in libraries or APIs.

 Slower than SHA-2 on many platforms.


---

####  BLAKE and BLAKE2 / BLAKE3

**BLAKE** is a cryptographic hash function that was one of the finalists in the SHA-3 competition. Though it didn’t win (Keccak did), it gave rise to successors:

- **BLAKE2**: A fast, secure alternative to MD5, SHA-1, and SHA-2.

- **BLAKE3**: Released in 2020, it's even faster and more modern, designed for high performance and parallelism.

 Based on ChaCha, a secure stream cipher.

 Uses a tree structure in BLAKE3, making it well-suited to multi-core processors.


**Use cases:**

 BLAKE2 is widely used in applications like IPFS, ZeroTier, and some blockchain systems.

 BLAKE3 is great for hashing large data efficiently (e.g., backups, file verification).

**Drawbacks:**

 BLAKE3 is relatively new, so adoption is still growing.

 Some conservative systems prefer NIST-endorsed algorithms like SHA-2/SHA-3.


---

### Tiger

Tiger is a fast hash function designed for use on 64-bit platforms. It produces a 192-bit hash and is known for its speed.

 Designed with 64-bit operations in mind, making it very efficient on 64-bit CPUs.

 Uses a Feistel structure and S-boxes like in block ciphers.


**Use cases:**

 File integrity verification.

 Backup systems (used in older tools like TTH in file-sharing apps).


 **Drawbacks:**

 Not widely used anymore.

 Has not seen the same level of scrutiny as SHA and BLAKE families.



---

#### Bcrypt

Based on the Blowfish cipher.

 Introduces a "cost factor" to control how slow it is.

Automatically handles salting internally.


**Strength:** Proven and widely used (e.g., in Linux systems and web apps).  

**Weakness:** Not well-suited for environments where you can use GPU acceleration to crack hashes.

---

####  Scrypt

 Builds on bcrypt but adds **memory-hardness**, which makes it costly for attackers to parallelize attacks using GPUs or ASICs.


**Strength:** More resistant to large-scale attacks.  

**Weakness:** Requires more memory and configuration tuning.

---

####  Argon2

The most modern and flexible password hashing algorithm.

Comes in three versions:

 **Argon2d** – Resistant to GPU cracking.

**Argon2i** – Resistant to side-channel attacks.

 **Argon2id** – Hybrid of both.


**Strength:** Current recommended standard for password hashing.  

**Weakness:** More complex to implement correctly without using a library.

---

### Recognising Password Hashes

Automated hash recognition tools such as `hashID` exist but are unreliable for many formats.

If you find the hash in a web application database, it’s more likely to be MD5 than NTLM (NT LAN Manager). Automated hash recognition tools often get these hash types mixed up, highlighting the importance of learning yourself.


#### Linux Passwords

On Linux, password hashes are stored in `/etc/shadow`, which is normally only readable by root. They used to be stored in `/etc/passwd`, which was readable by everyone.

The shadow file contains the password information. Each line contains nine fields, separated by colons (:). The first two fields are the login name and the encrypted password. More information about the other fields can be found by executing man 5 shadow on a Linux system.

The encrypted password field contains the hashed passphrase with four components: prefix (algorithm id), options (parameters), salt, and hash. It is saved in the format` $prefix$options$salt$hash. `

The prefix makes it easy to recognise Unix and Linux-style passwords; it specifies the hashing algorithm used to generate the hash.

Here’s a quick table of some of the most common Unix-style password prefixes you might encounter. They are listed in the order of decreasing strength. You can read more about them by checking the man page with **man 5 crypt**.

| **Prefix**                     | **Algorithm**                                                                                                                                                                                        |
| ------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `$y$`                          | **yescrypt** is a scalable hashing scheme and is the default and recommended choice in new systems                                                                                                   |
| `$gy$`                         | **gost-yescrypt** uses the GOST R 34.11-2012 hash function and the yescrypt hashing method                                                                                                           |
| `$7$`                          | **scrypt** is a password-based key derivation function                                                                                                                                               |
| `$2b$`, `$2y$`, `$2a$`, `$2x$` | **bcrypt** is a hash based on the Blowfish block cipher originally developed for OpenBSD but supported on a recent version of FreeBSD, NetBSD, Solaris 10 and newer, and several Linux distributions |
| `$6$`                          | **sha512crypt** is a hash based on SHA-2 with 512-bit output originally developed for GNU libc and commonly used on (older) Linux systems                                                            |
| `$md5`                         | **SunMD5** is a hash based on the MD5 algorithm originally developed for Solaris                                                                                                                     |
| `$1$`                          | **md5crypt** is a hash based on the MD5 algorithm originally developed for FreeBSD                                                                                                                   |

#### MS Windows Passwords

MS Windows passwords are hashed using NTLM, a variant of MD4. They’re visually identical to MD4 and MD5 hashes, so it’s very important to use context to determine the hash type.

On MS Windows, password hashes are stored in the SAM (Security Accounts Manager). 

MS Windows tries to prevent normal users from dumping them, but tools like mimikatz exist to circumvent MS Windows security. 

Notably, the hashes found there are split into NT hashes and LM hashes.

A great place to find more hash formats and password prefixes is the [Hashcat Example Hashes](https://hashcat.net/wiki/doku.php?id=example_hashes) page. For other hash types, you’ll typically need to check the length or encoding or even conduct some research into the application that generated them.



**Password Cracking Practical**


---
### Applications of Cryptographic Algorithms

#### 1. Digital Signatures

A digital signature is a cryptographic technique used to verify the authenticity and integrity of digital data or messages. It ensures that the information has not been tampered with and provides assurance about the identity of the sender. Digital signatures are widely used in securing emails, software distribution, financial transactions, and other forms of communication.

 **How Digital Signatures Work**

Digital signatures rely on public key cryptography (asymmetric encryption). The process involves two keys: a **private key** and a **public key**.

1. **Creating a Digital Signature**:
   - The sender uses their private key to generate the digital signature.
   - A hash function is applied to the message or document to produce a fixed-length hash value (a unique fingerprint of the data).
   - This hash value is then encrypted using the sender's private key, creating the digital signature.

2. **Verifying a Digital Signature**:
   - The receiver uses the sender's public key to decrypt the digital signature, retrieving the original hash value.
   - The receiver independently computes the hash value of the received message or document.
   - If the decrypted hash value matches the computed hash value, the signature is valid, confirming the integrity of the message and the sender's identity.


### Creating Digital Signatures Practical

We will use OpenSSL to generate digital signatures.

To verify if **GPG** (GNU Privacy Guard) is installed:

```bash
gpg --version
```

To verify if OpenSSL is installed:

```bash
openssl version
```

If not installed, install them using:

```bash
sudo apt update && sudo apt install gnupg openssl
```


**Step 1: Create a data file**

```bash
echo 'data to sign' > my_data.txt

openssl dgst -sha256 < my_data.txt > hash
```


---
#### Using OpenSSL

**1.Create private/public key pair**

```bash
openssl genrsa -out private.pem 1024
```

**2. Extracting Public key.**

```bash
openssl rsa -in private.pem -out public.pem -outform PEM -pubout
```


**3. Sign the hash using Private key to a file called example.sha256**

```bash
openssl dgst -sha256 -sign private.pem -out signature.bin my_data.txt
```

**4. Verify the file (my_data.txt)and the digital signature (signature.bin)**

```bash
openssl dgst -sha256 -verify public.pem -signature signature.bin my_data.txt
```


---
#### Using GPG

1. Run the following command:
```c
gpg --full-generate-key
```

Follow the prompts to select:

- Key type (RSA and RSA is recommended).
- Key size (2048 or 4096 bits for better security).
- Expiration time.
- Name, email, and a passphrase to protect your private key.

2. Once generated, list your keys:

```c
gpg --list-keys
```

3. Sign a file:

```c
gpg --sign my_data.txt
```


This creates a file named `my_data.txt.gpg`

4. Share Your Public Key

Distribute your public key to those who need to verify your signature. With GPG, you can export your public key:

```c
gpg --export --armor "Your Name or Email" > public_key.asc
```

Verify the signature:

```c
gpg --verify file
```

For a detached signature:

```c
gpg --detach-sign my_data.txt
```

This creates a `my_data.txt.sig`

---

 **Benefits of Digital Signatures**

- **Authentication**: Confirms the identity of the sender.
- **Integrity**: Ensures the message has not been altered during transit.
- **Non-Repudiation**: Prevents the sender from denying they sent the message, as only their private key could have created the signature.

 **Applications of Digital Signatures**

- **Email Security**: Verifying sender identity and ensuring email content integrity.
- **Document Signing**: Legally binding electronic agreements and contracts.
- **Software Distribution**: Ensuring that software updates and packages come from a trusted source.
- **Blockchain and Cryptocurrencies**: Securing transactions and validating ownership.

---

#### 2. Digital Certificates

A digital certificate is an electronic document used to prove the ownership of a public key. It acts as a digital passport, linking the public key to the identity of an individual, organization, or entity. Digital certificates are issued by trusted third parties known as **Certificate Authorities (CAs)**.

 **Purpose of Digital Certificates**
 
Digital certificates provide assurance that:

- The public key belongs to the claimed entity.
- The entity has been verified by a trusted authority.
- Communication using the public key can be trusted.

**Structure of a Digital Certificate**

A digital certificate typically contains:

- **Certificate Holder Information**: Name, email, or organization details.
- **Public Key**: The public key of the entity.
- **Certificate Authority Information**: Name and details of the issuing CA.
- **Validity Period**: Start and expiration dates of the certificate.
- **Serial Number**: A unique identifier for the certificate.
- **Digital Signature**: The CA's signature, ensuring the certificate's authenticity.

 **How Digital Certificates Work**

1. **Issuance**:
   - The entity requesting a certificate generates a public-private key pair.
   - The public key, along with identity details, is submitted to a CA for verification.
   - The CA verifies the entity's identity and issues a digital certificate.

2. **Verification**:
   - When a digital certificate is presented, the recipient verifies it using the CA's public key.
   - If valid, the certificate confirms the identity of the holder and the trustworthiness of the public key.


Let’s say you have a website and want to use HTTPS. This step requires having a TLS certificate. You can get one from the various certificate authorities for an annual fee. Furthermore, you can get your own TLS certificates for domains you own using [Let's Encrypt](https://letsencrypt.org/) for free. If you run a website, it’s worth setting up and switching to HTTPS, as any modern website would do.

---
### Creating Digital Certificates Practical 


##### 1. Create a Private Key

Generate a private key with a 2048-bit RSA algorithm:

```bash
openssl genrsa -out private.key 2048
```

This file, `private.key`, will be used to sign your certificate.

---

##### 2. Create a Certificate Signing Request (CSR)

Generate a CSR to include your information:

```bash
openssl req -new -key private.key -out request.csr
```

You will be prompted to provide the following details:

- **Country Name (2-letter code)**: e.g., `US`
- **State or Province Name**: e.g., `California`
- **Locality Name (City)**: e.g., `San Francisco`
- **Organization Name**: e.g., `MyCompany`
- **Organizational Unit Name**: e.g., `IT Department`
- **Common Name**: e.g., `mydomain.com` or your name.
- **Email Address**: e.g., `admin@mydomain.com`

---

##### 3. Create a Self-Signed Certificate

Use the private key and CSR to create a self-signed certificate:

```bash
openssl x509 -req -days 365 -in request.csr -signkey private.key -out certificate.crt
```

- `-days 365`: Validity period of 1 year.
- `certificate.crt`: The output certificate file.

---

##### 4. Verify the Certificate

Check the contents of the certificate:

```bash
openssl x509 -in certificate.crt -text -noout
```

---

##### 5. Use Your Certificate

You can now use `certificate.crt` for various purposes:

- To secure a website (HTTPS).
- To sign documents.
- For local testing purposes.

---

 **Types of Digital Certificates**

- **SSL/TLS Certificates**: Secures websites by encrypting data between the user and the server.
- **Code Signing Certificates**: Ensures the authenticity of software or applications.
- **Email Certificates**: Secures email communication by enabling encryption and digital signatures.
- **Client Certificates**: Verifies the identity of an individual in secure communications.
- **Root Certificates**: Used by CAs to sign and issue other certificates.

 **Benefits of Digital Certificates**

- **Authentication**: Ensures the identity of parties involved in a communication.
- **Encryption**: Protects sensitive data by enabling secure encryption.
- **Integrity**: Verifies that transmitted data has not been altered.
- **Trust**: Builds trust in digital communication by involving trusted CAs.

 **Example of Digital Certificate Use**

In a secure website connection (HTTPS):

1. A user visits a secure website.
2. The website presents its SSL/TLS certificate.
3. The user's browser verifies the certificate with the issuing CA.
4. If valid, an encrypted connection is established between the user and the website.

---

## SSH 

SSH is a cryptographic network protocol for secure communication over an unsecured network. Here’s a breakdown of the key aspects you’re interested in:

**1. Authenticating the Server**

When a client connects to an SSH server for the first time, the server presents its public key. The client stores this key in a file (usually `~/.ssh/known_hosts`). On subsequent connections, the client verifies the server’s identity by comparing the presented key with the stored one. This prevents man-in-the-middle attacks.

- **Example**: If the server’s key changes (e.g., due to reinstallation), the client will warn you of a potential security issue.


**2. Authenticating the Client**

Clients can authenticate to the server using:
- **Password Authentication**: The client provides a username and password. This is simple but vulnerable to brute-force attacks.
- **Public Key Authentication**: The client proves ownership of a private key corresponding to a public key stored on the server. This is more secure and commonly used.

**3. `ssh-keygen`**

This tool generates SSH key pairs (public and private keys). 

It supports various algorithms, as shown below:

- **DSA (Digital Signature Algorithm)** is a public-key cryptography algorithm specifically designed for digital signatures.
  
- **ECDSA (Elliptic Curve Digital Signature Algorithm)** is a variant of DSA that uses elliptic curve cryptography to provide smaller key sizes for equivalent security.
  
- **ECDSA-SK (ECDSA with Security Key)** is an extension of ECDSA. It incorporates hardware-based security keys for enhanced private key protection.
  
- **Ed25519** is a public-key signature system using EdDSA (Edwards-curve Digital Signature Algorithm) with Curve25519.
  
- **Ed25519-SK (Ed25519 with Security Key)** is a variant of Ed25519. Similar to ECDSA-SK, it uses a hardware-based security key for improved private key protection.


```
man ssh-keygen
```

Here’s how it works:

- **Command**: `ssh-keygen -t ed25519` (or `-t rsa -b 4096` for RSA keys).
- **Output**: Two files:
  - `id_ed25519` (private key, must be kept secret).
  - `id_ed25519.pub` (public key, shared with the server).

- **Example**: 
  
  ```bash
  ssh-keygen -t ed25519 -C "your_email@example.com"
  ```


 **4. SSH Private Keys**

SSH private keys are crucial components of SSH key-based authentication, enabling secure remote access to servers. 

They are kept secret by the user and used to prove identity to the server during authentication. 

When combined with a corresponding public key, they form a key pair, allowing for secure communication. 

Never share them under any circumstances; they’re called private keys for a reason. 

Someone with your private key can log in to servers that accept it, i.e., include it among the authorised keys, unless the key is encrypted with a passphrase.

Private keys are sensitive and should be protected:

- **Permissions**: Set strict permissions (`chmod 600 ~/.ssh/id_ed25519`).
- **Passphrase**: Encrypt the private key with a passphrase for added security.
- **Storage**: Never share or expose the private key.


**5. Using SSH Keys to Get a “Better Shell”**

SSH keys can enhance your shell experience:
- **Passwordless Login**: Configure the server to accept your public key (`~/.ssh/authorized_keys`), allowing seamless logins.
- **Agent Forwarding**: Use `ssh-agent` to forward your private key for accessing other servers from the first one.
  
- **Example**:
  
  ```bash
  ssh -A user@server1  # Forward keys to server1
  ssh user@server2     # Use forwarded keys to log into server2
  ```


---
## Steganography

Steganography is the practice of concealing information within another medium, such as an image, audio file, video, or text, in a way that hides the existence of the hidden data. 

Unlike cryptography, which makes data unreadable to unauthorized users, steganography aims to keep the very presence of the data undetectable.

### Types of Steganography

1. **Text Steganography**

 Text Steganography is defined as a type of steganography which involves caching dispatches or secret information within a textbook document or other textual data.
 
2. **Image Steganography**

Image Steganography is defined as a type of steganography which involves caching dispatches or secret information within digital images. 

3. **Audio Steganography**

Audio Steganography is defined as a type of steganography which involves caching dispatches or secret information within audio lines.

4. **Video Steganography**

Video Steganography is defined as a type of steganography which involves caching dispatches or secret information within digital videotape lines.

5. **Network Steganography**

Video Steganography is defined as a type of steganography which involves caching dispatches or secret information within data packets.

---

## Steghide Practical



##### 1. Embedding Data in a Carrier File

```c
steghide embed -cf [carrier_file] -ef [secret_file] -p [password]
```

- **`-cf`**: Specifies the carrier file.
- **`-ef`**: Specifies the file to hide.
- **`-p`**: Sets a password for retrieving the hidden data.


```c
steghide embed -cf image.jpg -ef secret.txt -p mypassword
```

This embeds `secret.txt` into `image.jpg` using the password `mypassword`.

---

##### 2. Extracting Data from a Carrier File

```c
steghide extract -sf [carrier_file] -p [password]
```

- **`-sf`**: Specifies the carrier file containing hidden data.
- **`-p`**: Provides the password to access the hidden data.

```c
steghide extract -sf image.jpg -p mypassword
```

This extracts the hidden `secret.txt` from `image.jpg` using the password `mypassword`.

Verify if Image has Embeded Files

``` c
steghide info image.jpg
```

---
##### 1. Hide Data Inside an Audio File

To embed a text file (secret.txt) inside an audio file (audio.mp3), use:

```c
steghide embed -cf audio.wav -ef secret.txt
```

- `cf`: Cover file (the audio file).
- `ef`: Embedded file (the file you want to hide).

You will be prompted to set a passphrase. Choose a strong passphrase for security.

```c
ffmpeg -i audio.mp3 -acodec pcm16le -ar 44100 audio.wav
```

---
##### 2. Verify the Hidden Data

To check if data has been embedded inside the audio file:

```c
steghide info audio.wav
```

If data is hidden, it will confirm the presence of embedded information.

---

##### 3. Extract the Hidden Data

To retrieve the hidden file:

```c
steghide extract -sf audio.wav
```

- `sf`: Stego file (audio file containing the hidden data).

Enter the correct passphrase, and the hidden file will be extracted.

---

### Method 2: Using FFmpeg with Silent Data Embedding

If Steghide does not work well with MP3 files, you can try using **ffmpeg** with a steganography approach.

##### Step 1: Convert Text to Audio

Convert a text file into an audio file (WAV format):

```c
cat secret.txt | text2wave -o secret.wav
```

##### Step 2: Merge the Secret Audio with the Cover Audio

Merge it with an existing audio file:

```c
ffmpeg -i audio.mp3 -i secret.wav -filter_complex "[0:a][1:a]amix=inputs=2:duration=longest" output.mp3
```

##### Step 3: Extract the Hidden Audio

You can use **Audacity** to extract the hidden audio by separating the sound layers.

- Launch Audacity
- Click **File > Open** and select `output.mp3`.

```c
ffmpeg -i output.mp3 -af areverse reversed.mp3
```

Then, open `reversed.mp3` in Audacity.


---
### Applications of Steganography

 **Data Confidentiality**:
- Transmits sensitive data covertly, hiding the presence of the communication.

 **Watermarking**:
- Embeds ownership or copyright information into media files (images, videos, etc.).

 **Digital Rights Management (DRM)**:
- Protects intellectual property by embedding information about usage rights.

 **Covert Communications**:
- Used in scenarios where secrecy is crucial, such as intelligence operations.

 **Authentication**:
- Embeds metadata or hidden tags to verify the authenticity of documents or media.

---

### Advantages of Steganography

- Maintains secrecy by hiding the presence of data.
- Difficult to detect without specialized tools.
- Can be combined with cryptography for enhanced security.

---

### Limitations of Steganography

- **Vulnerability to Detection**: Steganalysis techniques can identify hidden data by analyzing patterns.
- **Limited Capacity**: The amount of hidden data depends on the medium.
- **Degradation Risk**: Alterations to the medium (e.g., image compression) may destroy the hidden data.

---

### Steganography vs. Cryptography

|**Aspect**|**Steganography**|**Cryptography**|
|---|---|---|
|**Goal**|Hides the existence of data.|Scrambles data to make it unreadable.|
|**Detection**|Difficult to detect if done correctly.|Presence of encrypted data is obvious.|
|**Combination**|Often used together for enhanced security.|Cryptographic data can be embedded using steganography.|

---

### Steganography Tools

- OpenStego
- Steghide
- OutGuess
- Hide n shoot
- QuickStego
- Disguise

### Hardware-Based Mechanisms for Protecting Data

Hardware-based mechanisms are designed to provide robust protection for sensitive data by using physical devices or components that are resistant to attacks or unauthorized access. These mechanisms are often more secure than software-based solutions because they are less vulnerable to certain types of attacks, such as malware or remote exploitation. 

 **Full Disk Encryption (FDE) Using Hardware**

 FDE is implemented at the hardware level to encrypt the entire storage device (e.g., hard drive or SSD) so that data is automatically encrypted before being written to disk and decrypted when accessed.
 
**Functions**:

- Transparent encryption and decryption without requiring user intervention.
- Hardware-based encryption offloading to reduce system resource usage.

**Applications**:

- Protecting data on laptops and desktop computers from unauthorized access if the device is lost or stolen.
- Used in enterprise environments to secure endpoints.

**USB Hardware Encryption Drives**

These are physical USB drives equipped with hardware encryption capabilities. They automatically encrypt data stored on the drive and require authentication to access it.

**Functions**:

- On-the-fly encryption and decryption of data.
- Protects against unauthorized access in case of theft or loss.

**Applications**:

- Portable data storage for sensitive information.
- Secure file transfer between devices

---


### Software-Based Mechanisms for Protecting Data

Software-based mechanisms are designed to protect sensitive data through the use of software applications or configurations. 

While these mechanisms are more flexible and easier to deploy than hardware solutions, they may be more vulnerable to software-based attacks such as malware, ransomware, or unauthorized access.

#### Encryption Software

Encryption software is used to encode data so that only authorized users or systems can decrypt and access it.

**Types of Encryption:**

- Full Disk Encryption (FDE): Encrypts the entire disk to protect all stored data (e.g., BitLocker, FileVault).

- File or Folder Encryption: Encrypts individual files or folders (e.g., AxCrypt, VeraCrypt).

- End-to-End Encryption: Ensures that only the sender and receiver can decrypt messages (e.g., Signal, WhatsApp).

Applications:

- Protects sensitive files, emails, or data on portable devices like laptops.
- Ensures confidentiality in transit, such as during email or messaging.

#### Password Management Software

Password management software stores and manages passwords in an encrypted vault, reducing the risk of password-related security breaches.

**Functions:**

- Generates and stores complex passwords.
- Encrypts password databases for protection.
- Facilitates secure password sharing and password recovery.

**Applications:**

- Helps individuals and organizations manage multiple accounts and passwords securely.
- Prevents password theft or leaks by securely storing login information.


#### Secure File Transfer Software

Software designed to encrypt files and ensure their secure transfer over untrusted networks (e.g., the internet).

**Functions:**

- Encrypts files during transmission using protocols like FTPS or SFTP.
- Ensures the integrity of the data being transferred.
- Provides secure authentication and authorization for file access.

**Applications:**

- Protects sensitive data during file sharing or transfer between systems or users.
- Used in industries like finance, healthcare, and legal sectors for secure document exchange.

## Data Masking

Data masking is the process of obfuscating or transforming sensitive data to protect it while maintaining its usability for testing, development, or analysis purposes. 

The goal is to prevent unauthorized access to sensitive information by replacing the original data with a masked version that is functionally similar but does not expose actual confidential details. 

This technique is commonly used in environments where sensitive data needs to be used for non-production purposes, such as in development or testing.

#### Types of Data Masking Techniques

1. **Static Data Masking (SDM)**  
   A process that creates a masked copy of the original dataset, with sensitive data obfuscated for non-production environments.

2. **Dynamic Data Masking (DDM)**  
   Masks data in real-time, allowing sensitive information to be protected based on user roles or permissions without altering the original dataset.

3. **Deterministic Data Masking**  
   Replaces the original data with fixed, consistent masked values that always map to the same masked value for each occurrence.

4. **Non-Deterministic Data Masking**  
   Replaces data with random values, ensuring that no predictable relationships exist between the original and masked data.

5. **Substitution**  
   Replaces sensitive data with realistic but fictitious values, maintaining the format but obfuscating the actual information.

6. **Shuffling**  
   Randomly rearranges data within a field or column, obscuring relationships between values.

7. **Date Shifting**  
   Replaces dates with shifted values, maintaining the date format while altering the actual date to ensure privacy.

8. **Nulling Out**  
   Replaces sensitive data with null or empty values, effectively removing the data while retaining the structure of the field.

 **Advantages of Data Masking**

- **Data Protection**: Safeguards sensitive information during testing, development, and other non-production activities.
- **Compliance**: Helps ensure compliance with data privacy regulations (e.g., GDPR, HIPAA, PCI-DSS).
- **Preserves Data Integrity**: Allows data to be used effectively in development and testing environments without exposing sensitive content.
- **Reduces Risk**: Limits the risk of data breaches by preventing the exposure of real sensitive data.


**Limitations of Data Masking**

- **Complexity**: Implementing data masking can be complex, particularly in large, dynamic systems.
- **Performance Impact**: Some techniques (e.g., real-time masking) may have performance overheads.
- **Non-Deterministic Masking**: In some cases, non-deterministic techniques might make it difficult to preserve the relationships between masked data.
- **Not a Complete Solution**: While masking helps protect data, it should be used in conjunction with other security mechanisms (e.g., encryption, access controls).

#### **Data Erasure**

**Data erasure** is the process of permanently and irreversibly removing data from a storage device, ensuring that it cannot be recovered or accessed. 

This is different from simply deleting files or formatting a disk, as those methods often leave residual data that can be recovered using special tools.

Data erasure ensures that sensitive information is completely wiped from the storage medium to prevent unauthorized access or data recovery.

---

**Key Concepts of Data Erasure**

**1. Complete Data Destruction**
Data is wiped such that it cannot be recovered, ensuring the privacy of sensitive information.

**2. Irreversible Process**
Once data is erased, there is no way to recover or reconstruct it, even with advanced forensic tools.

**3. Compliance**
Data erasure is used to comply with data privacy laws and regulations (e.g., GDPR, HIPAA, PCI-DSS) that require data to be permanently erased when no longer needed.

**4. Methods**
Data erasure can be performed using various software tools or hardware methods, such as physical destruction of storage devices.

---

 **Advantages of Data Erasure**

- **Data Security**: Protects sensitive data from unauthorized access after disposal or decommissioning of storage devices.
- **Compliance**: Helps organizations comply with legal and regulatory data retention and destruction requirements.
- **Environmental Responsibility**: When combined with physical destruction, it ensures that devices are safely disposed of, protecting both data privacy and the environment.

---

**Limitations of Data Erasure**

- **Residual Data**: In some cases, particularly with older technologies or faulty equipment, residual data may still be recoverable.
- **Performance Impact**: Software-based erasure can be time-consuming, especially with large volumes of data.
- **Cost**: Physical destruction or degaussing of storage devices may incur additional costs, especially for large-scale data erasure.

### Biometric Security

**Biometric security** refers to the use of unique physiological or behavioral characteristics to verify the identity of individuals. These traits are considered difficult to replicate or steal, making them a highly effective form of authentication for securing access to systems, devices, and physical locations.

#### Types of Biometric Security

**Fingerprint Recognition**

Uses the unique patterns of ridges and valleys on a person’s fingertip to verify identity. It's one of the most commonly used biometric methods, found in smartphones and other security systems.

**Facial Recognition**

Analyzes the unique features of a person’s face, such as the distance between eyes, nose shape, and overall face structure. This method is used in various security systems and surveillance tools.

**Iris Recognition**

Scans the unique patterns in the iris of the eye to verify identity. The iris is highly stable over time, making this method highly accurate and secure.

**Retina Scanning**

Captures the unique pattern of blood vessels in the back of the eye (retina). Retina scans are highly accurate but typically require specialized equipment.

**Voice Recognition**

Analyzes the unique characteristics of a person's voice, including pitch, tone, and speech patterns. It is used in phone-based authentication systems and voice-activated assistants.

**Hand Geometry Recognition**

Measures and analyzes the shape and size of a person’s hand. It’s less accurate than other methods but still used in certain environments, such as access control systems.

**Signature Recognition**

Analyzes the unique patterns and dynamics of how a person writes their signature, including pressure, speed, and stroke order. This method is used for document verification and digital signatures.

**Gait Recognition**

Analyzes the way a person walks to identify them. It’s still an emerging technology, with potential applications in surveillance and security.

**Vein Recognition**

Uses infrared light to capture the unique patterns of veins in a person's hand or finger. It's a highly accurate method, but the technology is less common.

 **Advantages of Biometric Security**

- **Convenience**: Biometric systems are generally easy to use, as individuals do not need to remember passwords or carry tokens.
- **Accuracy**: Biometric traits are unique to each individual, offering a high level of authentication accuracy.
- **Security**: Since biometric data is hard to replicate or steal, it provides a robust layer of security.
- **Non-transferable**: Unlike passwords or cards, biometrics cannot be easily transferred or shared.

 **Challenges of Biometric Security**

- **Privacy Concerns**: The collection and storage of biometric data raise significant privacy issues, as it is sensitive and personal information.
- **False Positives/Negatives**: No system is perfect, and biometric systems may occasionally fail to recognize a legitimate user (false negative) or incorrectly authenticate an unauthorized user (false positive).
- **Data Storage**: Storing biometric data securely is crucial. If biometric data is compromised, it cannot be changed like a password or PIN.
- **Cost**: Implementing biometric systems can be expensive due to the specialized equipment and infrastructure required.


 **Use Cases of Biometric Security**

- **Mobile Devices**: Many smartphones use fingerprint, facial, or iris recognition for user authentication.
- **Banking and Payments**: Some financial institutions use voice recognition or fingerprint scanning for secure transactions and account access.
- **Access Control**: Biometric systems are widely used in physical security systems, such as building entry, to verify the identity of employees or authorized personnel.
- **Healthcare**: Hospitals and clinics use biometric systems to secure access to patient records and verify staff identities.
- **Surveillance**: Law enforcement and security agencies use facial recognition and other biometric systems for monitoring and identifying individuals in crowds or on surveillance footage.

---



